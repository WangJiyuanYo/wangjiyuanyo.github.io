(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["about"],{"07bd":function(o,t,n){"use strict";n.r(t);var e=function(){var o=this,t=o.$createElement;o._self._c;return o._m(0)},r=[function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",{staticStyle:{width:"100%",height:"100%"}},[n("h1",[o._v("项目主页")])])}],a={name:"Project",components:{}},i=a,g=n("2877"),p=Object(g["a"])(i,e,r,!1,null,"0bc460b4",null);t["default"]=p.exports},"1f64d":function(o,t,n){},3976:function(o,t,n){},"550d":function(o,t){var n='<h1 id="spring-boot入门">Spring Boot入门</h1> <h2 id="1springboot简介">1.SpringBoot简介</h2> <blockquote> <p>简化SPring开发的一个框架；</p> <p>整合Spring技术栈的一个大集合</p> <p>J2EE开发的一站式解决方案</p> </blockquote> <h2 id="微服务">微服务</h2> <p>微服务是一种架构风格</p> <p>一个应用应该是一组小型服务：可以通过HTTP的方式进行互通</p> <p>每一个功能元素最终都是一个可独立替换和升级的软件单元</p> <p><a href="https://www.martinfowler.com/articles/microservices.html">微服务文档</a></p> <h1 id="spring-boot-helloworld">Spring Boot HelloWorld</h1> <p>1.创建Maven 工程</p> <p>2.导入相关依赖</p> <pre><code class="language-xml">&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;</code></pre> <p>3.主程序启动SpringBoot</p> <pre><code class="language-Java">@SpringBootApplication\npublic class HelloWorldMainApplication {\n    public static void main(String[] args) {\n        //启动\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    }\n}</code></pre> <p>4编写相关的Controller、、、</p> <pre><code class="language-Java">@Controller\npublic class HelloController {\n\n    @ResponseBody\n    @RequestMapping(&quot;/hello&quot;)\n    public String hello(){\n        return &quot;Hello World&quot;;\n    }\n}</code></pre> <p>5.运行主程序测试</p> <p>6.简化部署</p> <pre><code class="language-xml">    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;</code></pre> <p>将这个应用打包成Jar包，直接使用-java -jar运行</p> <h1 id="springboot配置文件">SpringBoot配置文件</h1> <p>​ SpringBoot使用一个全局配置文件</p> <p>​ application.properties</p> <p>​ application.yml</p> <p>作用：修改Spring Boot的默认值；</p> <p>YAML：一个标记语言</p> <p>标记语言：以前大多数配置文件都是 xxx.xml文件</p> <p>以数据为中心，比Json\\xml等更适合做配置文件</p> <h3 id="1三种配置方式">1.三种配置方式</h3> <p>xml配置方式：</p> <pre><code class="language-xml">&lt;server&gt;\n    &lt;port&gt;8081&lt;/port&gt;\n&lt;/server&gt;</code></pre> <p>application.properties配置方式</p> <pre><code class="language-properties">server.port=8081</code></pre> <p>application.yml配置方式</p> <pre><code class="language-yaml">server:\n  port: 8081</code></pre> <h3 id="2yaml语法">2.YAML语法</h3> <h4 id="1基本语法：">1.基本语法：</h4> <p>K: v：表示一对键值对(必须有空格)</p> <p>以<strong>空格</strong>的缩进来控制层级的关系；只要左对齐的一列数据，都是同一个层级的</p> <pre><code class="language-yml">server:\n  port:8080\n  path:/hello</code></pre> <p>属性和值大小写敏感</p> <h4 id="2值的写法字面量">2.值的写法字面量</h4> <p><strong>（数字，字符串，布尔）</strong></p> <p>​ K:v：字面直接来写</p> <p>​ 字符串默认不加单引号或双引号</p> <p>​ &quot;&quot;：双引号会转义字符串里面的特殊字符</p> <p>​ name:&quot;zhangsan \\n lisi&quot; 输出：zhangsan 换行 lisi</p> <p>​ &#39;&#39;：单引号不会转义特殊字符</p> <p>​ name:&quot;zhangsan \\n lisi&quot; 输出：zhangsan \\n lisi</p> <p><strong>对象，Map（属性和值）（键值对）</strong></p> <p>​ 对象还是k:v的值</p> <pre><code class="language-yaml">friends:\n    lastname:zhangsan\n    age:20</code></pre> <p>行内写法</p> <pre><code>friends:{lastName:zhangsan,age:20}</code></pre><p><strong>数组（List Set）</strong></p> <p>用值表示数组中的一个元素</p> <pre><code class="language-yaml">pets:\n- cat\n- dog\n- pig</code></pre> <p>行内写法</p> <pre><code class="language-yaml">pets:[cat,dog,pig]</code></pre> <h4 id="3配置文件注入">3.配置文件注入</h4> <p>配置文件：</p> <pre><code class="language-yaml">server:\n  port: 8081\n\nperson:\n   lastName: zhangsan\n   age: 18\n   boss: false\n   birth: 2017/12/12\n   maps: {k1: v1,k2: v2}\n   lists:\n     - lisi\n     - zhaoliu\n   dog:\n     name: 小狗\n     age: 2</code></pre> <p>JavaBean:</p> <pre><code class="language-java">@Component\n@ConfigurationProperties(prefix = &quot;person&quot;)\npublic class Person {\n\n     /**\n      * @description: 把每一个属性的值映射到组件中\n      */\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Date birth;\n\n    private Map&lt;String ,Object &gt; maps;\n    private List&lt;Object&gt;lists;\n    private Dog dog;\n</code></pre> <p>我们可以导入配置文件处理器。以后编写配置文件就有提示了</p> <pre><code class="language-xml">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;</code></pre> <h4 id="两种注解的比较">两种注解的比较</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816000153150.png" alt="image-20200816000153150"></p> <h1 id="propertysourceimportresource">@PropertySource&amp;@ImportResource</h1> <p>@PropertySource：加载指定的配置文件</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816225818485.png" alt="image-20200816225818485"></p> <p>@ImportResource：导入Spring的配置文件，让配置文件内的内容生效</p> <p>SpringBoot里面没有Spring的配置文件。我们自己写的配置文件，也不能自动识别</p> <p>想让Spring的配置文件生效，加载进来；<strong>@ImportResource</strong>标注在一个<strong>配置类</strong>上</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816230827053.png" alt="image-20200816230827053"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816230924331.png" alt="image-20200816230924331"></p> <p>SptringBoot推荐给容器中添加组建的方式：推荐使用全注解方式</p> <p>1.配置类====Spring配置文件</p> <p>2.使用@Bean给容器添加组件</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816231834694.png" alt="image-20200816231834694"></p> <h1 id="配置文件占位符">配置文件占位符</h1> <h2 id="1、随机数">1、随机数</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817113435140.png" alt="image-20200817113435140"></p> <h2 id="2占位符获取之前配置的值，如果没有可以设置默认值">2.占位符获取之前配置的值，如果没有可以设置默认值</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817113548183.png" alt="image-20200817113548183"></p> <h1 id="profile">Profile</h1> <h2 id="1多profile文件">1.多Profile文件</h2> <p>我们在配置文件编写的时候，文件名可以是<strong>application-{profile}.properties/yml</strong></p> <p>默认使用application.properties</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817114905310.png" alt="image-20200817114905310"></p> <h2 id="2yml支持多文档块方式">2.yml支持多文档块方式</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817115454532.png" alt="image-20200817115454532"></p> <h2 id="3激活指定profile">3.激活指定Profile</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817114925425.png" alt="image-20200817114925425"></p> <p>1.在配置文件中指定 spring.profiles.cative=dev</p> <p>2.命令行:</p> <p>​ <strong>--spring.profiles.active=dev</strong></p> <p>打包后的命令行</p> <p><strong>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</strong></p> <p>可以直接在测试时，传入命令行参数</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817115817429.png" alt="image-20200817115817429"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817120220370.png" alt="image-20200817120220370"></p> <p>3.虚拟机参数</p> <p><strong>-Dspring.profiles.active=dev</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817120505331.png" alt="image-20200817120505331"></p> <h1 id="配置文件加载位置（优先级）">配置文件加载位置（优先级）</h1> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817171214218.png" alt="image-20200817171214218"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818175136302.png" alt="image-20200818175136302"></p> <p>优先级由高到低，高优先级配置会覆盖低优先级的配置；</p> <p>SpringBoot会从这四个位置全部加载主配置文件：<strong>互补配置</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817171943050.png" alt="image-20200817171943050"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817172015097.png" alt="image-20200817172015097">、</p> <p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p> <p>项目打包后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817172748534.png" alt="image-20200817172748534"></p> <h1 id="自动配置原理">自动配置原理</h1> <p><strong>自动配置原理</strong></p> <p>1）SpringBoot启动的时候加载主配置类，开启了自动配置功能<strong>@EnableAutoConfiguration</strong></p> <p>2)@EnableAutoConfiguration作用：</p> <p>​ 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p> <p>​ 可以插件selectImports()的内容 获取候选的配置</p> <pre><code class="language-java"> List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></pre> <p>将类路径下META/INF/spring.factories里面所用EnableAutoConfigration的值加入到容器中</p> <pre><code class="language-properties"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</code></pre> <p>3)每一个这样的类：xxxAutoConfigration类都是容器中的一个组件；都加入到容器中；用他们来做自动配置</p> <p>4)以<strong>HttpEncodingAutoConfiguration</strong>为例解释自动配置原理</p> <pre><code class="language-java">@Configuration(\n    proxyBeanMethods = false\n)   //表示这是一个配置类，和配置文件一样，向容器中添加组件\n@EnableConfigurationProperties({ServerProperties.class}) //启动指定的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中\n@ConditionalOnWebApplication(  //Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；  判断当前应用是否是web应用，如果是当前配置类生效。\n    type = Type.SERVLET\n)\n@ConditionalOnClass({CharacterEncodingFilter.class}) //判断当前项目是否存在这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器\n\n@ConditionalOnProperty( //判断配置文件中是否存在某个配置server.servlet.encoding.enable;如果不存在也为true；\n    //即使不配置为true也默认为生效\n    prefix = &quot;server.servlet.encoding&quot;,\n    value = {&quot;enabled&quot;},\n    matchIfMissing = true\n)\n\n\npublic class HttpEncodingAutoConfiguration {\n\n    //他已经和springBoot的配置文件映射\n    private final Encoding properties;\n    //只有一个油藏构造器的情况下，参数的值从容器中拿\n    public HttpEncodingAutoConfiguration(ServerProperties properties) {\n        this.properties = properties.getServlet().getEncoding();\n    }\n\n\n    @Bean //给容器中添加一个组件；这个组件的某些值需要从properties中获取\n    @ConditionalOnMissingBean\n    public CharacterEncodingFilter characterEncodingFilter() {\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));\n        return filter;\n    }\n}\n</code></pre> <p>根据当前不同的条件判断，决定这个配置类是否生效</p> <p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p> <p>5）所有配置文件中能配置的属性都是在xxxProperties类中的封装者；配置文件将能配置什么就可以参照某个功能对应的这个属性类</p> <pre><code class="language-java">@ConfigurationProperties(   //从配置文件中获取指定的值和Bean的属性进行绑定\n    prefix = &quot;server&quot;,\n    ignoreUnknownFields = true\n)</code></pre> <p><strong>精髓：</strong></p> <p>​ <strong>1）SpringBoot启动会加载大量的自动配置类</strong></p> <p>​ <strong>2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</strong></p> <p>​ <strong>3）我们在看这个自动配置类中到底配置了那些组件（只要我们要用到的组件有，我们就不需要再来配置类）</strong></p> <p>​ <strong>4）给容器中自动配置类添加组件的时候，会从Properties类中获取某些属性。我们就可以在配置文件中指定这些属性</strong></p> <p>xxxAutoConfigurartion：自动配置类</p> <p>给容器中添加组件</p> <p>xxxProperties：封装配置文件中相关属性；</p> <h2 id="细节："><strong>细节</strong>：</h2> <p>@Conditional：条件为true则像容器中添加组件，配置里面的所有内容才生效</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818190716900.png" alt="image-20200818190716900"></p> <p><strong>自动配置类必须在一定条件下才能生效</strong></p> <p>我们怎么知道那些自动配置类生效</p> <p>启动Debug=ture属性让控制台打印报告，我们就可以很方便的知道那些配置类生效</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818191548079.png" alt="image-20200818191548079"></p> <h1 id="spring-boot与日志">Spring Boot与日志</h1> <h1 id="日志">日志</h1> <h2 id="1日志框架">1.日志框架</h2> <p>底层是SpringBoot；底层是Spring框架，Spring框架默认用的是JCL</p> <p> <strong>SpringBoot选用SLF4和logback</strong></p> <h2 id="2slfj的使用">2.SLFj的使用</h2> <h3 id="1如何在系统中使用slf4j">1.如何在系统中使用SLF4j</h3> <p>开发的时候，日志记录方法的调用，不应该来直接俄调用日志的实现类，而是调用日志抽象层的方法：</p> <p>给系统里面导入slf4j的Jar和logback的实现Jar </p> <pre><code class="language-java">import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(&quot;Hello World&quot;);\n  }</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819230535396.png" alt="image-20200819230535396"></p> <p>每一个日志的实现框架都有自己的配置文件，使用slf4j以后<strong>，配置文件还是做成日志实现框架自己本身的配置文件</strong></p> <h3 id="2依赖框架">2.依赖框架</h3> <p>a（slf4j+logback）：Spring（commons-logging）Hibernate(jboss-logging) </p> <p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819231517927.png" alt="image-20200819231517927"></p> <p><strong>==如何让系统中所有的日志统一到dslf4j？</strong>==</p> <ol> <li>==将系统中其他日志框架先排除出去：==</li> <li>==用中间包来替换原有的日志框架；==</li> <li>==导入slf4j其他的实现==</li> </ol> <h2 id="3spring-boot日志关系">3.Spring Boot日志关系</h2> <pre><code class="language-xml">    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;</code></pre> <p>​ SpringBoot使用它来</p> <pre><code class="language-xml">    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n      &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n      &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819232853247.png" alt="image-20200819232853247"></p> <p>总结：</p> <p>1）SB底层也是使用slf4j+logback的记录方式进行日志记录</p> <p>2) SB也把其他的日志都替换成了slf4j</p> <p>3) 中间替换包</p> <p>4）如果要引入其他框架，一定要把这个框架的默认依赖移除掉</p> <p>​ SP使用的是commons-logging</p> <p>SP能自动适配所有的日志，而且底层使用slf4j_logback的方式记录日志，引入其他框架的时候自动排出</p> <h2 id="4日志使用；">4.日志使用；</h2> <h3 id="1默认配置">1.默认配置</h3> <p>​ SP默认配置好了日志；</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235036010.png" alt="image-20200819235036010"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235053431.png" alt="image-20200819235053431"></p> <h4 id="loggingfilename">Logging.file.name</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235804460.png" alt="image-20200819235804460"></p> <h4 id="loggingfilepath">Logging.file.path</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235712590.png" alt="image-20200819235712590"></p> <h4 id="loggingpatternfile---loggingpatternconsole">Logging.pattern.file &amp; Logging.pattern.console</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200820000418187.png" alt="image-20200820000418187"></p> <h1 id="四、web开发">四、Web开发</h1> <p>使用SB开发</p> <p>1）创建项目应用选中所需要的组件</p> <p>2）SB默认配置好场景，只需要在配置文件中指定少量配置就可以运行起来</p> <p>3）自己编写业务代码</p> <p>自动配置原理：</p> <h1 id="五、整合数据库">五、整合数据库</h1> <h2 id="1整合druid">1.整合Druid</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201004002500755.png" alt="image-20201004002500755"></p> <pre><code class="language-yaml">spring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://localhost:3306/plant\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\n    initiaSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    filters: stat,wall,log4j\n    MaxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    ConnectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</code></pre> <p>config/DruidConfig</p> <pre><code class="language-java">\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druid() {\n        return new DruidDataSource();\n    }\n\n    //配置监控\n    //1. 管理后台的Servlet\n\n    @Bean\n    public ServletRegistrationBean statViewServlet() {\n        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);\n        Map&lt;String, String&gt; initMaps = new HashMap&lt;&gt;();\n\n        initMaps.put(&quot;loginUsername&quot;, &quot;admin&quot;);\n        initMaps.put(&quot;loginPassword&quot;, &quot;admin&quot;);\n        // 不写允许所有\n        initMaps.put(&quot;allow&quot;, &quot;&quot;);\n\n        bean.setInitParameters(initMaps);\n        return bean;\n    }\n\n    //2. 配置Filtter\n    public FilterRegistrationBean WebStatFilter() {\n        FilterRegistrationBean bean = new FilterRegistrationBean();\n        bean.setFilter(new WebStatFilter());\n\n        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();\n        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);\n        bean.setInitParameters(initParams);\n\n        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));\n        return bean;\n    }\n}</code></pre> <h2 id="2整合mybatis">2.整合Mybatis</h2> <h3 id="配置druid">配置Druid</h3> <h3 id="配置mybatis驼峰命名">配置MyBatis驼峰命名</h3> <p>路径在/config/MyBatisConfig</p> <pre><code class="language-java">@org.springframework.context.annotation.Configuration\npublic class MyBatisConfig {\n\n    @Bean\n    public ConfigurationCustomizer configurationCustomizer() {\n        return new ConfigurationCustomizer() {\n            @Override\n            public void customize(Configuration configuration) {\n                configuration.setMapUnderscoreToCamelCase(true);\n            }\n        };\n    }\n}\n</code></pre> <pre><code class="language-Java">使用MapperScan批量扫描Mapper所有的接口\n@MapperScan(value = &quot;com.atfuigu.springboot06mybatis.mapper&quot;)</code></pre> <p>xml文件使用驼峰命名</p> <pre><code class="language-xml">resources/mybatis/mybatis-config.xml\n\n&lt;configuration&gt;\n    &lt;settings&gt;\n        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;</code></pre> ';o.exports=n},"5cd4":function(o,t){var n='<p>[TOC]</p> <h1 id="spring-farmwork">Spring Farmwork</h1> <h1 id="官网：">官网：</h1> <blockquote> <p>Spring.io</p> </blockquote> <h1 id="spring-是什么：">Spring 是什么：</h1> <blockquote> <p>Spring是分层的Java SE/EE应用<font color="red">full-stack</font>轻量级开源框架</p> </blockquote> <h1 id="spring的两大核心：">Spring的两大核心：</h1> <p><font color="red">IOC（反转控制）</font> </p> <blockquote> <p><font color="red">削减耦合</font>，降低依赖关系(把创建对象的权力交给框架或者工厂)</p> </blockquote> <p><font color="red">AOP（面向切面编程）</font>为内核，提供展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</p> <h1 id="创建bean的三种方式">创建Bean的三种方式</h1> <p>创建Bean的三种方式:</p> <p>第一种方式：使用默认构造函数创建。 在Spring的配置文件中使用Bean标签，配以ID和CLASS属性之后，且没有其他属性和标签时 采用的就是默认构造函数创建Bean对象，此时如果类中没有构造函数，则对象无法创建</p> <pre><code class="language-xml"> &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</code></pre> <p>第二种方式：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入Spring容器）</p> <pre><code class="language-xml">     &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;\n\n    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre> <p>第三种方法： 使用工厂中的静态方法创建对象，(使用某个类中的静态方法创建对象，并存入Spring容器)</p> <pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre> <h1 id="bean的作用范围">Bean的作用范围</h1> <p>Bean标签的Scope属性:</p> <pre><code>作用：用于指定Bean的作用范围\n取值：\nsingleton : 单例的（默认值）\nprototype :多例的\nrequest   :作用域Web应用的请求范围\nsession   :作用域Web应用的会话范围\nglobal-session：作用域集群环境的会话范围（全局会话范围），不是集群环境时，他就是Session</code></pre><pre><code class="language-xml"> &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\n</code></pre> <h1 id="bean对象的生命周期">Bean对象的生命周期</h1> <pre><code>单例对象：\n    出生：容器创建出生\n    活着：只要容器在，对象一直存活\n    死亡：容器消失，对象消亡\n    总结：单例对象的生命周期和容器相同\n多例对象：\n    出生：使用对象时，Spring创建\n    活着：对象在使用过程中，一直活着\n    死亡：当对象长时间不用，且没有其他对象引用时由Java垃圾回收机制回收；</code></pre><h1 id="spring的依赖注入">Spring的依赖注入</h1> <ol> <li><p>Spring中的依赖注入 Dependency Injection IOC的作用：降低耦合（依赖关系） 依赖关系的管理：以后交给Spring维护 在当前类需要用到其他类的对象，由Spring为我们提供。我们只需要在配置文件中 说明</p> </li> <li><p>依赖关系的维护： 就称之为依赖注入 依赖注入：</p> <blockquote> <p>​ 能注入的数据：有三类 ​ 1.基本类型和String</p> <p>​ 2.其他的Bean类型</p> <p>​ 3.复杂类型/集合类型</p> <p> 注入的方式有三种：</p> <p>​ 1.第一种：使用构造函数提供</p> <p>​ 2.第二种：使用set方法提供</p> <p>​ 3.第三种：使用注解提供</p> </blockquote> </li> </ol> <h2 id="构造函数注入：">构造函数注入：</h2> <p>第一种：构造函数注入 constructor-arg 在Bean标签的内部使用</p> <pre><code class="language-xml">&lt;bean&gt;\n&lt;constructor-arg&gt;\n&lt;/bean&gt;</code></pre> <p>属性：</p> <blockquote> <p>type：用于指定要注入的数据的数据类型 index：用于指定要注入的数据给构造函数的索引位置 name:用于指定给构造函数中指定名称的参数赋值</p> </blockquote> <p><font color="red">以上三个用于指定给构造函数中哪个参数赋值</font></p> <hr> <blockquote> <p>value:用于提供基本类型过和String类型的数据</p> <p>ref : 用于指定其他的Bean类型数据。在Spring的IOC核心容器中出现过的Bean对象</p> </blockquote> <p>总结：</p> <blockquote> <p>优势： 在获Bean对象时，注入是必须的操作，否则无法创建成功 弊端： 该拜年了Bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据也必须提供</p> </blockquote> <pre><code class="language-xml">    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;\n        &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt;\n        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;\n        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n\n    &lt;!--    配置一个日期--&gt;\n    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;\n\n</code></pre> <h2 id="set注入">Set注入</h2> <p>涉及的标签：property</p> <p>出现的位置：Bean标签的内部</p> <p>标签的属性：</p> <blockquote> <p>name:用于指定注入时所调用的set方法名称；</p> <p>value:用于提供基本类型过和String类型的数据</p> <p>ref : 用于指定其他的Bean类型数据。在Spring的IOC核心容器中出现过的Bean对象</p> </blockquote> <p>总结：</p> <blockquote> <p>优势：</p> <p>​ 创建时有明确的限制，可以直接使用默认构造函数</p> <p>弊端：</p> <p>​ 如果有某个成员必须有值，则获取对象有可能Set方法没有执行</p> </blockquote> <pre><code class="language-xml">    &lt;!--    Set 注入--&gt;\n    &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;特斯拉&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre> <h2 id="复杂类型的注入">复杂类型的注入</h2> <p>用于给List集合注入的标签：list array set</p> <p>用于给Map结构集合注入的标签：map props</p> <p>结构相同，标签可以互换</p> <h1 id="注解：">注解：</h1> <p>XML文件配置：</p> <pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;\n\n* 用于创建对象过的注解\n    在XML配置文件中编写一个&lt;bean&gt;表爱去哪实现功能是一样的\n     @Component:\n        作用：把当前类对象存入Spring容器中\n        属性：value用于指定Bean的id。不写时默认值为当前类名，且首字母小写\n   @Controller    ：用于表现层\n   @Service      ：用于业务层\n   @Respository    ：用于持久层\n        以上三个注解，他们的作用和属性与Compontent是一模一样的，\n        是Spring框架为我们提供明确的三层使用的注解，是我们的三层对象更加清晰\n* 用于注入数据的        \n        在XML配置中的bean中写一个&lt;property&gt;标签一样\n   @Autowired:\n        作用：自动按照类型注入，只要容器中有唯一的一个Bean对象类型和要注入的变量类型匹配，就可以注入成功；\n              如果IOC容器中没有任何Bean的类型和要注入的变量类型匹配，则报错\n              如果有多个类型匹配时\n        出现位置：可以是变量上，可以是方法上\n        细节：在使用注解时,set方法就可以不用\n   @Qualified：必须依赖于Autowired\n        作用：在按按照而理性注入的基础上再按照名称注入。它在给类成员注入时不能单独使用；但给参数注入时可以\n           属性：value：用于指定注入bean的ID\n   @Resource\n        作用：直接按照bean的ID注入，可以单独使用\n        属性：\n              name:用于指定bean的ID\n           以上三个注解，只能注入其他Bean类型的术后据，而基本类型和String类型无法使用上述注解实现。\n        另外，类型集合的注入只能通过XML实现\n\n\n   @Value：\n        作用：用于注入基本类型和String类型\n        属性：value：用于指定数据的值，可以使用Spring中SpEL（Spring中的el表达式）\n             SpEL写法：${表达式}\n* 改变作用范围的\n        作用集合在bean标签中使用scop标签是一样的\n   @Scope \n        作用：用于指定Bean的作用范围\n        属性：\n            Value：指定范围的取值，Singleton、Prototype\n* 生命周期相关（了解）\n        作用和bean标签中使用init-method,destroy-method\n   @PreDestroy：\n           指定销毁方法\n  @ PostContruct：\n        指定初始化方法\n</code></pre> <h1 id="configration注解：">Configration注解：</h1> <pre><code class="language-xml">@Configuration    \n    作用：\n        指定当前类是一个配置类\n    细节：\n        1.当配置类作为AnnotationCondifApplicationContext对象创建时，该注解可不写\n        2.\n@ComponentsScan：\n    作用：\n        用于指定Spring创建容器时所需要扫描的包\n    属性：\n        value:它和basePackkages的作用是一样的，都是指定窗户将容器时所要扫描的包\n              此注解等同与在XML中配置了&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;\n@Bean:\n    作用：\n        把当前方法的返回值作为Bean对象存入Spring容器中\n    属性：\n        naem:用于指定bean的ID，不写诗，默认值为当前方法的名称\n    细节：\n        当使用注解配置方法时，如果方法有参数，Spring框架会去容器中查找有没有可用的Bean对象，查找的方式和Autowied一致\n@Import\n    作用：用于导入其它的配置类\n    属性：\n        value:用于指定其他配置类的字节码\n              放我们使用Import注释的是父配置类，而导入的是子配置类\n@PropertySource :\n        作用：用于指定Peoperties文件的位置\n属性：values:指定文件路径和名册和名称\n        关键字classpath</code></pre> <h1 id="spring-test注解">Spring Test注解</h1> <pre><code class="language-java">\n\n@Runwith\n        :提供一个注解，把原有的main方法替换了，替换成Spring提供的\n\n@ContextConfigration\n        ：location：指定xml位置，加上class path关键字，表示在类路径下（@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)\n）\n        classes：指定注解类所在位置</code></pre> <h1 id="aop">AOP</h1> <h2 id="实例分析：">实例分析：</h2> <p>解决多个进程问题，无法回滚</p> <h2 id="动态代理对象">动态代理对象</h2> <h3 id="demo基于接口的动态代理">Demo:基于接口的动态代理</h3> <blockquote> <pre><code>   动态代理\n\n   特点：字节码随用随创建、加载\n       不修改源码的基础上对方法进行增强\n   分类：\n\n           基于接口的动态代理\n           基于子类的动态代理\n\n           基于接口的动态代理：\n                   涉及的类Proxy\n                   提供者：JDK官方\n            如何创建代理对象：\n                   使用Proxy类中的 newProxyInstance\n            创建代理对象的要求：\n                   被代理类最少实现一个接口，如果没有则不能使用\n           newProxyInstance方法的参数：\n                   ClassLoader : 用于加载对象字节码。和被代理对象使用相同的类加载器；固定写法\n                   Class[]：         让代理对象和被代理对象有相同的方法。固定写法\n                   InvocationHandle：  让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类；但不是必须的\n            此接口的实现类都是谁用谁写</code></pre></blockquote> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200811222212008.png" alt="image-20200811222212008"></p> <h3 id="demo基于子类的动态代理">Demo:基于子类的动态代理</h3> <blockquote> <pre><code>   动态代理\n\n   特点：字节码随用随创建、加载\n       不修改源码的基础上对方法进行增强\n   分类：\n\n   ​    基于接口的动态代理\n   ​    基于子类的动态代理\n\n   基于子类的动态代理：\n            涉及的类:Enhancer\n           提供者：第三方 cglib\n    如何创建代理对象：\n           使用Proxy类中的 Ehancer类中的Create方法\n    创建代理对象的要求：\n           被代理类不能是最终类\n   cerate方法的参数：\n           Class：字节码，用于指定被代理对象的字节码\n           Callback：  让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类；但不是必须的\n   ​    此接口的实现类都是谁用谁写\n   ​    我们一般写的都是该接口的子接口实现类:MethodInterceptor</code></pre></blockquote> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200811224451387.png" alt="image-20200811224451387"></p> <h2 id="aop概念及作用">AOP概念及作用</h2> <p>AOP：面向切面编程，是OOP的延续，是函数式编程的延续</p> <p>作用：在程序运行期间，不修改源码对已有方法进行增强</p> <p>优势：</p> <p>​ 减少重复代码</p> <p>​ 提高开发效率</p> <p>​ 维护方便</p> <h3 id="通知的类型：">通知的类型：</h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813155631126.png" alt="image-20200813155631126"></p> <h1 id="spring基于xml的aop配置步骤">Spring基于XML的AOP配置步骤</h1> <p>​ 1.把通知的Bean交给Logger来管理 ​ 2.使用AOP：config标签表示开始AOP的配置 ​ 3.使用Aop：aspect标签表明配置切面： ​ id属性：给切面提供一个唯一标志 ​ ref属性：指定通知类的Bean ID ​ 4.在aop:aspect内部使用对应标签来配置通知的类型 ​ aop:before 配置前置通知 ​ method属性：用于指定Logger类中哪个方法作为前置通知 ​ pointcut属性：用于指定切入点表达式。对业务层哪些方法进行增强</p> <p>​ 切入点从表达式的写法： ​ 关键字：execution(表达式) ​ 表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表） ​ 标准的表达式写法:public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813163613547.png" alt="image-20200813163613547"></p> <pre><code class="language-xml">&lt;!--    配置Spring的IOC，把service对象配置进来--&gt;\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;\n\n&lt;!--    Spring基于XML的AOP配置步骤\n    1.把通知的Bean交给Logger来管理\n    2.使用AOP：config标签表示开始AOP的配置\n    3.使用Aop：aspect标签表明配置切面：\n            id属性：给切面提供一个唯一标志\n            ref属性：指定通知类的Bean ID\n     4.在aop:aspect内部使用对应标签来配置通知的类型\n            aop:before 配置前置通知\n                method属性：用于指定Logger类中哪个方法作为前置通知\n                pointcut属性：用于指定切入点表达式。对业务层哪些方法进行增强\n\n             切入点从表达式的写法：\n             关键字：execution(表达式)\n             表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）\n              标准的表达式写法:public void com.itheima.service.impl.AccountServiceImpl.saveAccount()\n--&gt;\n&lt;!--    配置Logger类--&gt;\n&lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;\n&lt;!--配置AOP--&gt;\n&lt;aop:config&gt;\n    &lt;!--        配置切面--&gt;\n    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;\n        &lt;!--            配置通知的类型并且建立通知方法和切入点方法的关联--&gt;\n        &lt;aop:before method=&quot;printLog&quot;\n                    pointcut=&quot;execution(public void com.itheima.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:before&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre> <h3 id="通配表达式的写法">通配表达式的写法</h3> <pre><code>             切入点从表达式的写法：\n             关键字：execution(表达式)\n             表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）\n              标准的表达式写法:&lt;font color=red&gt;public void com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                  访问修饰符可以省略：\n                        &lt;font color=red&gt;void com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                  返回值可以使用*，表示任意返回值\n\n                    *   &lt;font color=red&gt;com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                                      包名可以使用通配符，表示任意包，但是有几级包就需要写几个*.\n\n                                           * *.*.*.*.AccountServiceImpl.saveAccount()\n                                                                  包名可以使用..表示当前包及其子包\n                                                                       * *..AccountServiceImpl.saveAccount();\n                                                                                         类名和方法名都可以使用*通配\n\n                                                                                                   * *..*.*()\n                                                                                                                参数列表：\n                                                可以直接写数据类型：\n                                            基本类型直接写名称 int\n                                                              应用类型写包名.类名方式 java.lang.String\n                                                                                                                                    可以使用通配符表示任意类型，但必须有参数，\n                                                                                                                          可以使用..表示有无参数均可，有参数可以是任意类型\n                                                                                  全通配写法：* *..*.*(..)</code></pre><p> <font color="red">实际开发中通常写法：切到业务层实现类的所有方法: </font></p> <p>​ <font color="red"> * com.itheima.service.impl.<em>.</em>(..) </font></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813170532038.png" alt="image-20200813170532038"></p> <h2 id="环绕通知的写法：">环绕通知的写法：</h2> <pre><code>/**\n * 问题：\n * 当配置了环绕通知后，切入点方法没有执行，而通知方法执行了\n * 分析：\n * 通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点调用方法，而我们代码中没有\n * 解决：\n * Spring框架为我们提供一个接口：ProceedingJoinPoint，该接口有一个方法Proceed（）。此方法明确调用切入点方法\n * 该接口可以作为环绕方法的通知参数，在程序执行时，Spring框架会为我们提供该接口方法的实现类供我们使用\n *\n * Spring环绕通知\n *      他是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式\n **/</code></pre><p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813175349451.png" alt="image-20200813175349451"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813175330483.png" alt="image-20200813175330483"></p> <h2 id="注解通知：">注解通知：</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181443487.png" alt="image-20200813181443487"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181513663.png" alt="image-20200813181513663"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181530691.png" alt="image-20200813181530691"></p> <h1 id="spring中基于xml的声明式事务控制配置">Spring中基于XML的声明式事务控制配置</h1> <p>​ 1.配置事务管理器 ​ 2.配置事务的通知，需要约束,同时也需要AOP ​ 属性：</p> <p>​ id 给事务通知一个标识 ​ transaction-manager：给事务管理器通知提供一个事务管理器的引用 ​ 3.配置AOP通用切入点表达式 ​ 4.建立事务通知和表达式的关系 ​ 5.配置事务的属性: ​ 是在事务通知的tx:advice标签内部 ​ isolation=&quot;&quot; : 用于指定事务的隔离界别，默认值default表示使用数据库的级别 ​ propagation=&quot;&quot; ：用于指定十五点额传播行为，默认值时REQUIRED，表示一定有事务，增删改的选择。查询方法可以选择 SUPPORT ​ read-only=&quot;&quot;：用于指定事务是否支付，只有查询方法才能设置为True默认值为false，表示为可读写 ​ timeout=&quot;&quot;：事务的超时时间，默认值-1.永不超时；若指定了数值，以秒为单位 ​ rollback-for=&quot;&quot;：用于指定一个异常；但产生异常时；事务回滚；产生其它异常时，事务不回滚没有默认值。表示人任何异常都回 滚 ​ no-rollback-for=&quot;&quot; ：用于指定一个异常，但产生该异常时事务不回滚。产生其他异常时事务会回滚，没有默认值表示任何异常都 回滚</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814224346045.png" alt="image-20200814224346045"></p> <h1 id="spring中基于aopl的声明式事务控制配置">Spring中基于AOPL的声明式事务控制配置</h1> <p>​ 1.配置事务管理器 ​ 2.开启Spring对注解事务的支持 ​ 3.在需要事务支持的地方使用@Transactionz注解</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814225219908.png" alt="image-20200814225219908"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814225246382.png" alt="image-20200814225246382"></p> ';o.exports=n},"6fca":function(o,t,n){"use strict";n.r(t);var e=function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"docBackground",staticStyle:{"font-family":"'DejaVu Sans Mono'","text-align":"left","font-size":"20px"},domProps:{innerHTML:o._s(o.md)}})},r=[],a=n("550d"),i=n.n(a),g={name:"DocumentSpringCloud",data:function(){return{md:i.a}}},p=g,s=(n("d343"),n("2877")),u=Object(s["a"])(p,e,r,!1,null,"c1cbdb3c",null);t["default"]=u.exports},"7b54":function(o,t,n){"use strict";n("abfd")},"7bbe":function(o,t,n){o.exports=n.p+"img/github.85f8d56b.png"},9276:function(o,t,n){"use strict";n("e179")},9516:function(o,t,n){o.exports=n.p+"img/gmail.964b840e.png"},abfd:function(o,t,n){},af3a:function(o,t,n){o.exports=n.p+"img/wechat.a8fee2c3.png"},bb51:function(o,t,n){"use strict";n.r(t);var e=function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("div",{staticClass:"divBackground",staticStyle:{"font-family":"'DejaVu Sans Mono'"}},[e("h1",[o._v(o._s(o.saying)+"~")]),e("el-divider"),e("div",{staticClass:"paragraph",attrs:{id:"info"}},[e("h2",{attrs:{id:"about_me"}},[o._v("About Me")]),e("p",{staticStyle:{margin:"2%"}},[o._v(" "+o._s(o.profession)+" ")]),e("br"),e("el-divider"),o._m(0),e("h3",[o._v("2016-2020")]),e("p",{staticStyle:{margin:"2%"}},[o._v(" School of Computer Science & Technology , Tianjin University of Commerce ,Tianjin , China ")]),e("el-divider"),o._m(1),e("i",{staticClass:"el-icon-message",staticStyle:{"font-family":"'DejaVu Sans Mono'"}},[o._v(" "+o._s(o.Contact.email))]),e("br"),e("br"),e("img",{staticStyle:{height:"20px",width:"20px"},attrs:{src:n("af3a")}}),e("i",[o._v(" WeChat ID:"+o._s(o.Contact.wechat))]),e("el-divider"),o._m(2),o._m(3),e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticStyle:{background:"rgba(255,255,255,0.75)"},domProps:{innerHTML:o._s(o.md)}})],1),o._m(4)],1)},r=[function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("h2",{attrs:{id:"experience"}},[n("i",{staticClass:"el-icon-info"}),o._v("Experience")])},function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("h2",{attrs:{id:"Contact"}},[n("i",{staticClass:"el-icon-message"}),o._v("Contact")])},function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("h2",{attrs:{id:"Links"}},[n("i",{staticClass:"el-icon-share"}),o._v("Links")])},function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("div",{staticStyle:{margin:"2%"},attrs:{id:"links_ico"}},[e("a",{attrs:{href:"https://github.com/WangJiyuanYo"}},[e("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:n("7bbe")}})]),e("a",{attrs:{href:"https://t.me/tokrn"}},[e("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:n("f5f9")}})]),e("a",{attrs:{href:"https://mail.google.com/"}},[e("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:n("9516")}})])])},function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("footer",{staticClass:"footer",staticStyle:{"font-family":"Meath"}},[n("div",[o._v(" MIT Licensed | Copyright © 2018-2020 Vue.js lan ")])])}],a=(n("e4cb"),n("1f64d"),n("3976"),n("5cd4")),i=n.n(a),g={name:"Home",data:function(){return{saying:"Anything can't kill me , it will make me be better",profession:"Work as Computer Programmer Designer\n",imgSrc:n("cb54"),Contact:{email:" Gwangjiyuan@gmail.com",wechat:"Gwangjiyuan"},user:{},responseResult:{},language:{},md:i.a}}},p=g,s=(n("9276"),n("2877")),u=Object(s["a"])(p,e,r,!1,null,"7d0390d2",null);t["default"]=u.exports},bd83:function(o,t,n){},c305:function(o,t,n){"use strict";n.r(t);var e=function(){var o=this,t=o.$createElement;o._self._c;return o._m(0)},r=[function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",[n("h1",[o._v("404 Not Found")])])}],a={name:"notFound404"},i=a,g=n("2877"),p=Object(g["a"])(i,e,r,!1,null,"32235ab8",null);t["default"]=p.exports},d180:function(o,t,n){"use strict";n.r(t);var e=function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",[n("div",{staticClass:"divBackground"},[n("div",{staticStyle:{"margin-left":"5%",width:"15%","margin-top":"5em"},attrs:{id:"timeLine"}},[n("h2",[o._v("博客进展")]),n("Timeline")],1),n("h2",[o._v("TO DO")]),n("el-divider",{staticClass:"divider_class"}),o._m(0)],1)])},r=[function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",{staticStyle:{"margin-left":"5%",width:"20%","text-align":"left"},attrs:{id:"TO DO"}},[n("h3",[o._v("添加ME页面内容")]),n("h3",[o._v("添加项目内容")]),n("h3",[o._v("抽离时间栏")]),n("h3",[o._v("抽离Markdown组件")]),n("h3",[o._v("增加en语言")]),n("h3",[o._v("增加平台适配")])])}],a=function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("div",{staticClass:"block"},[n("el-timeline",o._l(o.activities,(function(t,e){return n("el-timeline-item",{key:e,attrs:{icon:t.icon,type:t.type,color:t.color,size:t.size,timestamp:t.timestamp}},[o._v(" "+o._s(t.content)+" ")])})),1)],1)},i=[],g={name:"Timeline",data:function(){return{activities:[{content:"开始项目",timestamp:"2020-06-28",size:"large",type:"primary",icon:"el-icon-more"},{content:"构建框架",timestamp:"2020-06-28",color:"#0bbd87"},{content:"导航栏背景",timestamp:"2020-06-30",color:" #0bbd87"},{content:"引入Markdown文件",timestamp:"2020-07-01",color:" #0bbd87"},{content:"修改路由",timestamp:"2020-07-01",color:" #0bbd87"},{content:"Beta 1版本发布",timestamp:"2020-07-04",color:" #0bbd87"},{content:"修改主页内容",timestamp:"2020-07-09",color:"#0bbd87"},{content:"调试后端API",timestamp:"2020-11-22",color:"#0bbd87"},{content:"引入语言切换",timestamp:"2020-11-29",color:"#0bbd87"},{content:"引入自定义字体",timestamp:"2020-12-07",color:"#0bbd87"},{content:"主页语言配置",timestamp:"2020年12月13日",color:"#0bbd87"},{content:"其他待加入",timestamp:"2020-11-22",color:"red"}]}}},p=g,s=n("2877"),u=Object(s["a"])(p,a,i,!1,null,"6ed9d9e0",null),c=u.exports,l=(n("1f64d"),{name:"Other",components:{Timeline:c}}),m=l,f=(n("7b54"),Object(s["a"])(m,e,r,!1,null,"3e32bf9f",null));t["default"]=f.exports},d343:function(o,t,n){"use strict";n("bd83")},e179:function(o,t,n){},e4cb:function(o,t,n){},f5f9:function(o,t,n){o.exports=n.p+"img/telegram.edc9a0ed.png"}}]);
//# sourceMappingURL=about.c7d8c1d2.js.map