(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["about"],{"07bd":function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticStyle:{width:"100%",height:"100%"}},[t("h1",[n._v("项目主页")])])}],a={name:"Project",components:{}},i=a,p=t("2877"),s=Object(p["a"])(i,o,r,!1,null,"0bc460b4",null);e["default"]=s.exports},"0c42":function(n,e){var t='<h1 id="vue相关依赖组件">VUE相关依赖组件</h1> <h2 id=""></h2> ';n.exports=t},"14c3":function(n,e,t){var o=t("c6b6"),r=t("9263");n.exports=function(n,e){var t=n.exec;if("function"===typeof t){var a=t.call(n,e);if("object"!==typeof a)throw TypeError("RegExp exec method returned something other than an Object or null");return a}if("RegExp"!==o(n))throw TypeError("RegExp#exec called on incompatible receiver");return r.call(n,e)}},"1a30":function(n,e){var t='<h1 id="computer">Computer</h1> <h2 id="windows-10-安装教程">Windows 10 安装教程</h2> <p>🤣🤣🤣🤣</p> <p>工具：至少8GU盘 、 PE制作器（WePe）</p> <p>教程：</p> <p>1、使用ISO模式制作U盘启动器</p> <p>华硕主板 ： ESC 选择进入</p> <p>技嘉主板: F12 进入主板选择</p> <p>2、进主板U盘启动</p> <p>3、选择第二项的win8PE 新机器m</p> <p>4、格式化C盘，选择iOS文件目录 ， 直接安装即可。</p> <p><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a> //原版的Windows镜像下载</p> <h2 id="windows-service-2003-enterprise">WIndows Service 2003 Enterprise</h2> <p>x64 激活密钥：</p> <p>MR78C-GF2CY-KC864-DTG74-VMT73</p> <h2 id="windows-xp-密钥">Windows xp 密钥</h2> <p>MRX3F-47B9T-2487J-KWKMF-RPWBY</p> <pre><code></code></pre><h2 id="百度云高速下载">百度云高速下载</h2> <p>工具：IDM + 油猴脚本 、 速盘 、 百度云管家。等等各种程序</p> <p>chrome安装油猴插件 </p> <p>脚本下载：<a href="https://tampermonkey.net/scripts.php">https://tampermonkey.net/scripts.php</a></p> <p>百度云插件:<a href="https://openuserjs.org/scripts/gxvv/EX-%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98">https://openuserjs.org/scripts/gxvv/EX-%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98</a></p> <p>退出网页版的用户账户，复制下载连接</p> <p>在IDM里面下载即可。</p> <p>IDM可配合超线程下载，最高线程数量能达到256个</p> <p>星愿浏览器也可以高速下载，唯一的缺点是下载压缩包会很慢。</p> <h2 id="访问google及海外网站">访问Google及海外网站</h2> <p>使用VPN系列服务</p> <p>工具推荐：SSR、Hosts</p> <p>可用hosts网址：<a href="https://github.com/racaljk/hosts/blob/master/hosts">https://github.com/racaljk/hosts/blob/master/hosts</a></p> <p>服务器自己寻找即可</p> <h2 id="office-2019-安装">Office 2019 安装</h2> <p><a href="https://www.52pojie.cn/thread-781052-1-1.html">https://www.52pojie.cn/thread-781052-1-1.html</a></p> <p><a href="https://www.52pojie.cn/thread-719550-1-1.html">https://www.52pojie.cn/thread-719550-1-1.html</a></p> <h2 id="百度云搜索工具">百度云搜索工具</h2> <p><a href="http://www.banyungong.org">www.banyungong.org</a></p> <p><a href="https://www.fastsoso.cn/">https://www.fastsoso.cn/</a></p> <h2 id="adb常用命令">ADB常用命令</h2> <p>adb -d shell sh /data/data/me.piebridge.brevent/brevent.sh //黑域 adb shell dpm set-device-owner com.hld.apurikakusu/.receiver.DPMReceiver // 黑洞 adb shell dpm set-device-owner com.catchingnow.icebox/.receiver.DPMReceiver //冰箱</p> <p>adb shell wm overscan 0,0,0,0 //显示导航栏 adb shell wm overscan 0,0,0,-160 //隐藏导航栏 adb shell pm list packages -f // 获取安装列表和路径 adb shell pm list packages //获取包名 adb unistall xxx //卸载XX adb root //提权，输入完没提示。 adb shell //进入adb shell模式，类似DOS。 cd data/system //进入“data/system”目录，锁屏密码文件在这个目录里！删掉就没有密码了~ rm password.key //锁屏密码就也被清除了（要是是手势密码就“rm gesture.key ”） am force-stop XXXXX //强行停止XXX mount -o remount -o rw /system //回车，重新挂载下system ps // adb shell 下查看系统进程 kill pid xxx // 查看后强行停止进程，并无法自启 adb pull XXX E:\\Test\\ttt // 将XX中的包提出到XXX文件下（不能是根目录）</p> <h2 id="cmd命令">CMD命令</h2> <p>calc 调用计算器</p> <p>dir 当前文件目录</p> <p>tree 树形结构</p> <p>wmic cpu get 查看CPU的具体信息</p> <p>ipconfig/flushdns 刷新IE缓存</p> <p>ping 测试网络是否通畅</p> <p>cd 进入目录</p> <p>cd.. 返回上一层目录</p> <p>ping -t <a href="http://www.baidu.com">www.baidu.com</a> //ping Baidu n次</p> <h2 id="putty命令">Putty命令</h2> <p>从本地上传文件</p> <pre><code>pscp -i d:\\test.ppk c:\\test.txt  user_name@server_ip:/tmp</code></pre><pre><code class="language-c++">\npscp -i C:\\Users\\Alphabet\\Desktop\\google_privateKey.ppk C:\\Users\\Alphabet\\Documents\\HBuilderProjects\\Github\\index.html  gwangjiyuan@35.236.106.14:/home/gwangjiyuan</code></pre> <p>从服务器下载文件</p> <pre><code>pscp -i d:\\test.ppk user_name@server_ip:/var/www/test.txt d:\\</code></pre><pre><code>//路由器安装opkg\nwget http://pkg.entware.net/binaries/mipsel/installer/installer.sh &amp;&amp; chmod +x installer.sh  &amp;&amp; ./installer.sh </code></pre><h1 id="programming">Programming</h1> <h2 id="c">c++</h2> <h3 id="析构函数">析构函数</h3> <pre><code class="language-c++">class Stock{\npublic:\n    ~Stock()                     //定义析构函数\n    {\n       std::cout &lt;&lt; &quot;调用了析构函数 &quot; &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n   {\n      Stock stock ;   \n   }               // 在部分开发环境中可能没有显示内容，把它放在块儿中即可\n    return 0;   //返回之前调用析构函数;\n}</code></pre> <h3 id="构造函数">构造函数</h3> <pre><code class="language-c++">#include &lt;iostream&gt;\nusing namespace std;\nclass A\n{\npublic:\n     A(){cout&lt;&lt;&quot;A::constructor&quot;&lt;&lt;endl;};\n     ~A(){cout&lt;&lt;&quot;A::deconstructor&quot;&lt;&lt;endl;};\n};\nclass B\n{\npublic:\n     B(){cout&lt;&lt;&quot;B::constructor&quot;&lt;&lt;endl;};\n     ~B(){cout&lt;&lt;&quot;B::deconstructor&quot;&lt;&lt;endl;};\n};\nclass C : public A\n{\npublic:\n     C(){cout&lt;&lt;&quot;C::constructor&quot;&lt;&lt;endl;};\n     ~C(){cout&lt;&lt;&quot;C::deconstructor&quot;&lt;&lt;endl;};\nprivate:\n//    static B b;\n     B b;\n};\nclass D : public C\n{\npublic:\n     D(){cout&lt;&lt;&quot;D::constructor&quot;&lt;&lt;endl;};\n     ~D(){cout&lt;&lt;&quot;D::deconstructor&quot;&lt;&lt;endl;};\n};\n\nint main(void)\n{\n    C* pd = new D();\n    delete pd;\n    return 0;\n}\n/* Output\n-----&gt;B b\nA::constructor\nB::constructor\nC::constructor\nD::constructor\nC::deconstructor\nB::deconstructor\nA::deconstructor\n\n-----&gt;static B b\nA::constructor\nC::constructor\nD::constructor\nC::deconstructor\nA::deconstructor\n */</code></pre> <h2 id="android-developer">Android Developer</h2> <h3 id="背景铺满">背景铺满</h3> <pre><code class="language-java">        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;0dp&quot;\n        android:scaleType=&quot;fitXY&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintEnd_toEndOf=&quot;parent&quot;\n        app:layout_constraintHorizontal_bias=&quot;0.0&quot;\n        app:layout_constraintStart_toStartOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot;\n        app:layout_constraintVertical_bias=&quot;0.0&quot;</code></pre> <h3 id="透明按钮">透明按钮</h3> <pre><code class="language-java"> app:layout_constraintTop_toTopOf=&quot;parent&quot; //全透明\n Android:background=&quot;#e0000000&quot;            //全透明\n android:background=&quot;#00000000&quot;            //半透明</code></pre> <h3 id="隐藏title">隐藏title</h3> <pre><code class="language-java">supportRequestWindowFeature(Window.FEATURE_NO_TITLE);\n\n</code></pre> <h3 id="toast-diy">Toast DIY</h3> <pre><code class="language-java">Toast toast(Avtivity , Text , Toast.LENGTH.SHORT);\ntoast.setGravity(Gravity.TOP , 0 , 0);    //最上方居中显示；\ntoast.show();</code></pre> <h1 id="tool">Tool</h1> <h2 id="git-命令：">Git 命令：</h2> <pre><code class="language-c++">//登陆账户和密码：\ngit config --global user.name &quot;wangjiyuanyo&quot;\ngit config --global user.email &quot;anonymous.z@yahoo.com&quot;\n//生成SSH key\ncd ~\nssh-keygen -t rsa -C &quot;anonymous.z@yahoo.com&quot;\n\n//测试git的连通性\nssh -T git@github.com\n\ngit clone \n\ngit status \n\ngit push\n\ngit pull\n\ngit --list\n\n//在当前目录新建一个Git代码库\n\n$ git init\n\n显示当前的Git配置\n$ git config --list\n\n编辑Git配置文件\n$ git config -e [--global]\n\n设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n\n添加指定文件到暂存区\n$ git add [file1][file2] ...\n\n添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n添加当前目录的所有文件到暂存区\n$ git add .\n\n对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1][file2] ...\n\n停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n改名文件，并且将这个改名放入暂存区\n$ git mv [file-original][file-renamed]\n\n提交暂存区到仓库区\n$ git commit -m [message]\n\n提交暂存区的指定文件到仓库区\n$ git commit [file1][file2] ... -m [message]\n\n提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n提交时显示所有diff信息\n$ git commit -v\n\n使用一次新的commit，替代上一次提交\n\n如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1][file2] ...\n\n 列出所有本地分支\n$ git branch\n\n列出所有远程分支\n$ git branch -r\n\n列出所有本地分支和远程分支\n$ git branch -a\n\n新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n切换到上一个分支\n$ git checkout -\n\n 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n 合并指定分支到当前分支\n$ git merge [branch]\n\n 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n 删除分支\n git branch -d [branch-name]\n\n 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n标签\n\n 列出所有tag\n$ git tag\n\n 新建一个tag在当前commit\n$ git tag [tag]\n\n 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n 删除本地tag\n$ git tag -d [tag]\n\n 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n查看tag信息\n$ git show [tag]\n\n 提交指定tag\n$ git push [remote] [tag]\n\n 提交所有tag\n$ git push [remote] --tags\n\n 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n七、查看信息\n\n 显示有变更的文件\n$ git status\n\n显示当前分支的版本历史\n$ git log\n\n 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n 显示暂存区和工作区的代码差异\n$ git diff\n\n 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@{0 day ago}&quot;\n\n 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n 显示当前分支的最近几次提交\n$ git reflog\n\n 从本地master拉取代码更新当前分支：branch 一般为master\n$ git rebase [branch]\n八、远程同步\n\n 下载远程仓库的所有变动\n$ git fetch [remote]\n\n 显示所有远程仓库\n$ git remote -v\n\n 显示某个远程仓库的信息\n$ git remote show [remote]\n\n 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n 推送所有分支到远程仓库\n$ git push [remote] --all\n九、撤销\n\n 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n 新建一个commit，用来撤销指定commit\n 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n十、其他\n\n 生成一个可供发布的压缩包\n$ git archive</code></pre> <h2 id="linux-常用命令">Linux 常用命令</h2> <p>1、cd命令</p> <p>这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p> <pre><code>cd /root/Docements # 切换到目录/root/Docements\n\ncd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  \n\ncd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</code></pre><p>2、ls命令</p> <p>这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p> <pre><code>-l ：列出长数据串，包含文件的属性与权限数据等\n\n-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）\n\n-d ：仅列出目录本身，而不是列出目录的文件数据\n\n-h ：将文件容量以较易读的方式（GB，kB等）列出来\n\n-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</code></pre><p>注：这些参数也可以组合使用，下面举两个例子：</p> <pre><code>ls -l #以长数据串的形式列出当前目录下的数据文件和目录\n\nls -lR #以长数据串的形式列出当前目录下的所有文件</code></pre><p>3、grep命令</p> <p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为</p> <pre><code>grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename</code></pre><p>它的常用参数如下：</p> <pre><code>-a ：将binary文件以text文件的方式查找数据\n\n-c ：计算找到‘查找字符串’的次数\n\n-i ：忽略大小写的区别，即把大小写视为相同\n\n-v ：反向选择，即显示出没有‘查找字符串’内容的那一行\n\n# 例如：\n\n# 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色\n\ngrep --color=auto &#39;MANPATH&#39; /etc/man.config\n\n# 把ls -l的输出中包含字母file（不区分大小写）的内容输出\n\nls -l | grep -i file</code></pre><p>4、find命令</p> <p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：</p> <pre><code>find [PATH] [option] [action]\n\n# 与时间有关的参数：\n\n-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；\n\n-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；\n\n-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；\n\n-newer file : 列出比file还要新的文件名\n\n# 例如：\n\nfind /root -mtime 0 # 在当前目录下查找今天之内有改动的文件\n\n# 与用户或用户组名有关的参数：\n\n-user name : 列出文件所有者为name的文件\n\n-group name : 列出文件所属用户组为name的文件\n\n-uid n : 列出文件所有者为用户ID为n的文件\n\n-gid n : 列出文件所属用户组为用户组ID为n的文件\n\n# 例如：\n\nfind /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件\n\n# 与文件权限及名称有关的参数：\n\n-name filename ：找出文件名为filename的文件\n\n-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件\n\n-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、\n\n             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；\n\n-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；\n\n-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示\n\n-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示\n\n# 例如：\n\nfind / -name passwd # 查找文件名为passwd的文件\n\nfind . -perm 0755 # 查找当前目录中文件权限的0755的文件\n\nfind . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</code></pre><p>5、cp命令</p> <p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下：</p> <pre><code>-a ：将文件的特性一起复制\n\n-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份\n\n-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行\n\n-r ：递归持续复制，用于目录的复制行为\n\n-u ：目标文件与源文件有差异时才会复制</code></pre><p>例如 ：</p> <pre><code>cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2\n\ncp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中</code></pre><p>6、mv命令</p> <p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：</p> <pre><code>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖\n\n-i ：若目标文件已经存在，就会询问是否覆盖\n\n-u ：若目标文件已经存在，且比目标文件新，才会更新</code></pre><p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p> <p>例如：</p> <pre><code>mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中\n\nmv file1 file2 # 把文件file1重命名为file2</code></pre><p>7、rm命令</p> <p>该命令用于删除文件或目录，remove之间，它的常用参数如下：</p> <pre><code>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息\n\n-i ：互动模式，在删除前会询问用户是否操作\n\n-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</code></pre><p>例如：</p> <pre><code>rm -i file # 删除文件file，在删除之前会询问是否进行该操作\n\nrm -fr dir # 强制删除目录dir中的所有文件</code></pre><p>8、ps命令</p> <p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p> <pre><code>-A ：所有的进程均显示出来\n\n-a ：不与terminal有关的所有进程\n\n-u ：有效用户的相关进程\n\n-x ：一般与a参数一起使用，可列出较完整的信息\n\n-l ：较长，较详细地将PID的信息列出</code></pre><p>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p> <pre><code>ps aux # 查看系统所有的进程数据\n\nps ax # 查看不与terminal有关的所有进程\n\nps -lA # 查看系统所有的进程数据\n\nps axjf # 查看连同一部分进程树状态</code></pre><p>9、kill命令</p> <p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p> <pre><code>kill -signal PID</code></pre><p>signal的常用参数如下：</p> <p>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p> <pre><code>1：SIGHUP，启动被终止的进程\n\n2：SIGINT，相当于输入ctrl+c，中断一个程序的进行\n\n9：SIGKILL，强制中断一个进程的进行\n\n15：SIGTERM，以正常的结束进程方式来终止进程\n\n17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</code></pre><p>例如：</p> <pre><code># 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程\n\nkill -SIGTERM %1 \n\n# 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得\n\nkill -SIGHUP PID</code></pre><p>10、killall命令</p> <p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：</p> <pre><code>killall [-iIe] [command name]</code></pre><p>它的参数如下：</p> <pre><code>-i ：交互式的意思，若需要删除时，会询问用户\n\n-e ：表示后面接的command name要一致，但command name不能超过15个字符\n\n-I ：命令名称忽略大小写\n\n# 例如：\nkillall -SIGHUP syslogd # 重新启动syslogd</code></pre><p>11、file命令</p> <p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p> <pre><code>file filename\n\n#例如：\n\nfile ./test</code></pre><p>12、tar命令</p> <p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p> <pre><code>-c ：新建打包文件\n\n-t ：查看打包文件的内容含有哪些文件名\n\n-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中\n\n-j ：通过bzip2的支持进行压缩/解压缩\n\n-z ：通过gzip的支持进行压缩/解压缩\n\n-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来\n\n-f filename ：filename为要处理的文件\n\n-C dir ：指定压缩/解压缩的目录dir</code></pre><p>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：</p> <pre><code>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称\n\n查询：tar -jtv -f filename.tar.bz2\n\n解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></pre><p>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p> <p>13、cat命令</p> <p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：</p> <pre><code>cat text | less # 查看text文件中的内容\n\n# 注：这条命令也可以使用less text来代替</code></pre><p>14、chgrp命令</p> <p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：</p> <pre><code>chgrp [-R] dirname/filename\n\n-R ：进行递归的持续对所有文件和子目录更改\n\n# 例如：\nchgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</code></pre><p>15、chown命令</p> <p>该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述。</p> <p>16、chmod命令</p> <p>该命令用于改变文件的权限，一般的用法如下：</p> <pre><code>chmod [-R] xyz 文件或目录\n\n-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</code></pre><p>同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</p> <pre><code># 例如：\n\n\n\nchmod 0755 file # 把file的文件权限改变为-rxwr-xr-x\n\n\n\nchmod g+w file # 向file的文件权限中加入用户组可写权限</code></pre><p>18、vim命令</p> <p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以从这里下载<a href="http://download.csdn.net/detail/ljianhui/6215287">vim常用操作</a>的详细说明。</p> <p>19、gcc命令</p> <p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：</p> <pre><code>-o ：output之意，用于指定生成一个可执行文件的文件名\n\n-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序\n\n-I ：增加编译时搜索头文件的路径\n\n-L ：增加编译时搜索静态连接库的路径\n\n-S ：把源文件生成汇编代码文件\n\n-lm：表示标准库的目录中名为libm.a的函数库\n\n-lpthread ：连接NPTL实现的线程库\n\n-std= ：用于指定把使用的C语言的版本\n\n# 例如：\n\n# 把源文件test.c按照c99标准编译成可执行程序test\n\ngcc -o test test.c -lm -std=c99\n\n#把源文件test.c转换为相应的汇编程序源文件test.s\n\ngcc -S test.c</code></pre><p>20、time命令</p> <p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：</p> <pre><code>time ./process\n\ntime ps aux</code></pre><p>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：</p> <p>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；</p> <p>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；</p> <p>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p> <p>注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。</p> <h1 id="vps搭建website">VPS搭建website</h1> <p>安装 yum 命令：sudo su apt-get install yum\\</p> <h1 id="computer-network">Computer Network</h1> <h3 id="三次握手">三次握手</h3> <h3 id="四次挥手">四次挥手</h3> <h1 id="os">OS</h1> <h1 id="mysql-错误">MySQL 错误</h1> <p>Unable to load authentication plugin &#39;caching_sha2_password&#39;.</p> <pre><code class="language-sql">ALTER USER &#39;student&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;pass123&#39;;</code></pre> <h1 id="frp-配置文件">Frp 配置文件</h1> <h2 id="server-">Server :</h2> <pre><code class="language-json">[common]\nbind_port = 7000\nvhost_http_port =80\ndashboard_port = 8080\ndashboard_user = wongjiyuan\ndashboard_pwd = www.gogole.com\nprivilege_token = qq794439137</code></pre> <h2 id="cilent-">Cilent :</h2> <pre><code>[common]\nserver_addr = 35.229.211.122\nserver_port = 7000\nprivilege_token = qq794439137\nlogin_fail_exit = false\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\n\nremote_port = 8888\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[mikutap]\ntype = http\nlocal_ip = 192.168.1.1\nlocal_port = 80\ncustom_domains = router.wongjiyuan.top\n\n[myweb01]\ntype = http\nlocal_ip = 192.168.1.2\nlocal_port = 8080\ncustom_domains = web.wongjiyuan.top\nlocations = /\n\n[myweb02]\ntype = http\nlocal_port = 8080\ncustom_domains = web.wongjiyuan.top\nlocations = /hrmapp\n\n[ftp21]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 21\nremote_port = 2121\n</code></pre><h2 id="frp-自启文件配置">Frp 自启文件配置</h2> <pre><code class="language-shell">sudo -i\ncd /lib/systemd/system\n然后使用nano编辑器新建frpc.service服务文件：\n\nnano frpc.service\n在文件中加入如下代码：\n[Unit]\nDescription=frpc\ndaemonAfter=network.target\n\n[Service]\nUser=root\nType=simple\nExecStartPre=/bin/sleep 10\nExecStart=/usr/local/frp/frpc -c /usr/local/frp/frpc.ini\n\n[Install]\nWantedBy=multi-user.target\n\n\n最后使用systemctl将frpc.service启动，同时设置frpc开机自启：\nsystemctl start frpc\nsystemctl enable frpc</code></pre> <h2 id="网站证书申请">网站证书申请</h2> <pre><code class="language-bash">apt update &amp;&amp; apt full-upgrade -y\napt install certbot\ncertbot certonly --standalone -n --agree-tos --email 794439137@qq.com --preferred-challenges http -d wongjiyuan.top</code></pre> <h1 id="nginx-部署vue">Nginx 部署VUE</h1> <pre><code>配置文件路径： /etc/nginx/sites-enabled\n项目部署路径：    /var/www\n</code></pre><p>Nginx 命令：</p> <pre><code class="language-bash">nginx                             #打开 nginx\nnginx -t                           #测试配置文件是否有语法错误\nnginx -s reopen                    #重启Nginx\nnginx -s reload                      #重新加载Nginx配置文件，然后以优雅的方式重启Nginx\nnginx -s stop                          #强制停止Nginx服务\nnginx -s quit                          #优雅地停止Nginx服务（即处理完所有请求后再停止服务）原文出处链接及本声明。</code></pre> ';n.exports=t},"1f64d":function(n,e,t){},"27fb":function(n,e,t){},3976:function(n,e,t){},"4bee":function(n,e){var t='<h1 id="java基础">Java基础</h1> <h2 id="final关键字">final关键字</h2> <p>　使用final关键字做标识有“最终的”含义。</p> <p>　　1. final 修饰类，则该类<strong>不允许被继承。</strong></p> <p>　　2. final 修饰方法，则该方法不允许被<strong>覆盖(重写)</strong>。</p> <p>　　3. final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的<strong>初始化属性必须有值</strong>，或在<strong>构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，</strong>且初始化之后就不能改了，<strong>只能赋值一次</strong>。</p> <ol start="4"> <li><p>final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为<strong>常量</strong>。</p> <hr> <h3 id="final变量">final变量</h3> <p>final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。<strong>其中类常量必须在声明时初始化，final成员常量可以在构造函数初始化。</strong></p> </li> </ol> <pre><code> final方法表示该方法不能被子类的方法重写，将方法声明为final，在编译的时候就已经静态绑定了，不需要在运行时动态绑定。final方法调用时使用的是invokespecial指令。\n\n ### final类\n\n final类不能被继承，final类中的方法默认也会是final类型的，java中的String类和Integer类都是final类型的。</code></pre><h3 id="final关键字的知识点">final关键字的知识点</h3> <ol> <li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值。</li> <li>本地变量必须在声明时赋值。 因为没有初始化的过程</li> <li>在匿名类中所有变量都必须是final变量。</li> <li>final方法不能被重写, final类不能被继承</li> <li>接口中声明的所有变量本身是final的。类似于匿名类</li> <li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li> <li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li> <li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li> </ol> <p>final方法的好处:</p> <ol> <li>提高了性能，JVM在常量池中会缓存final变量</li> <li>final变量在多线程中并发安全，无需额外的同步开销</li> <li>final方法是静态编译的，提高了调用速度</li> <li><strong>final类创建的对象是只可读的，在多线程可以安全共享</strong></li> </ol> <h2 id="super关键字">super关键字</h2> <p>　<strong>要注意的是：如果子类构造方法中既没有显示调用父类的构造方法，而父类没有无参的构造方法，则编译出错。</strong></p> <h2 id="java-中的内部类">Java 中的内部类</h2> <p>　内部类（ Inner Class ）就是定义在另外一个类<strong>里面</strong>的类。与之对应，包含内部类的类被称为外部类。</p> <p>　那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</p> <p>　答：内部类的主要作用如下：</p> <p>　　1. 内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类。</p> <p>　　2. 内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括<strong>私有的数据</strong>。</p> <p>　　3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</p> <p>　　内部类可分为以下几种：</p> <ul> <li>成员内部类</li> <li>静态内部类</li> <li>方法内部类</li> <li>匿名内部类　　</li> </ul> <h2 id="引用类型转换">引用类型转换</h2> <h3 id="1向上类型转换隐式自动类型转换，是小类型转换到大类型">　<strong>1.向上类型转换(隐式/自动类型转换)，是小类型转换到大类型</strong></h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200821104619933.png" alt="image-20200821104619933"></p> <h3 id="2-向下类型转换强制类型转换，是大类型转换到小类型有风险可能出现数据溢出。">　 <strong>2. 向下类型转换(强制类型转换)，是大类型转换到小类型(有风险,可能出现数据溢出)。</strong></h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200821104731130.png" alt="image-20200821104731130"></p> <h2 id="3-instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。">　 <strong>3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。</strong></h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200821104918610.png" alt="image-20200821104918610"></p> <h1 id="运算符和equals之间的区别：">==运算符和equals之间的区别：</h1> <p><strong>引用指向的内容和引用指向的地址</strong></p> <h2 id="java中的代码块简介">Java中的代码块简介</h2> <p>在java中用{}括起来的称为代码块，代码块可分为以下四种：</p> <p><strong>一.简介</strong></p> <p><strong>1.普通代码块：</strong></p> <p>类中方法的方法体</p> <p><strong>2.构造代码块</strong>：</p> <p>构造块会在创建对象时被调用，每次创建时都会被调用，优先于类构造函数执行。</p> <p><strong>3.静态代码块：</strong></p> <p>用static{}包裹起来的代码片段，只会执行一次。静态代码块优先于构造块执行。</p> <p><strong>4.同步代码块：</strong></p> <p>使用synchronized（）{}包裹起来的代码块，在多线程环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中。****</p> <h2 id="java代码块、构造方法（包含继承关系）的执行顺序">Java代码块、构造方法（包含继承关系）的执行顺序</h2> <h3 id="局部代码块">局部代码块</h3> <blockquote> <p>位置：局部位置（方法内部）</p> </blockquote> <blockquote> <p>作用：限定变量的生命周期，尽早释放，节约内存</p> </blockquote> <blockquote> <p>调用：调用其所在的方法时执行</p> <pre><code class="language-java"> public class 局部代码块 {\n@Test\npublic void test (){\n    B b = new B();\n    b.go();\n}\n}\nclass B {\n    B(){}\n    public void go() {\n        //方法中的局部代码块，一般进行一次性地调用，调用完立刻释放空间，避免在接下来的调用过程中占用栈空间\n        //因为栈空间内存是有限的，方法调用可能会会生成很多局部变量导致栈内存不足。\n        //使用局部代码块可以避免这样的情况发生。\n        {\n            int i = 1;\n            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n            while (i &lt; 1000) {\n                list.add(i ++);\n            }\n            for (Integer j : list) {\n                System.out.println(j);\n            }\n            System.out.println(&quot;gogogo&quot;);\n        }\n        System.out.println(&quot;hello&quot;);\n    }\n}</code></pre> </blockquote> <h3 id="构造代码块">构造代码块</h3> <blockquote> <p>位置：类成员的位置，就是类中方法之外的位置</p> </blockquote> <blockquote> <p>作用：把多个构造方法共同的部分提取出来，共用构造代码块</p> </blockquote> <blockquote> <p>调用：每次调用构造方法时，都会优先于构造方法执行，也就是每次new一个对象时自动调用，对 对象的初始化</p> </blockquote> <pre><code class="language-java">class A{\n    int i = 1;\n    int initValue;//成员变量的初始化交给代码块来完成\n    {\n        //代码块的作用体现于此：在调用构造方法之前，用某段代码对成员变量进行初始化。\n        //而不是在构造方法调用时再进行。一般用于将构造方法的相同部分提取出来。\n        //\n        for (int i = 0;i &lt; 100;i ++) {\n            initValue += i;\n        }\n    }\n    {\n        System.out.println(initValue);\n        System.out.println(i);//此时会打印1\n        int i = 2;//代码块里的变量和成员变量不冲突，但会优先使用代码块的变量\n        System.out.println(i);//此时打印2\n        //System.out.println(j);//提示非法向后引用，因为此时j的的初始化还没开始。\n        //\n    }\n    {\n        System.out.println(&quot;代码块运行&quot;);\n    }\n    int j = 2;\n    {\n        System.out.println(j);\n        System.out.println(i);//代码块中的变量运行后自动释放，不会影响代码块之外的代码\n    }\n    A(){\n        System.out.println(&quot;构造方法运行&quot;);\n    }\n}\npublic class 构造代码块 {\n    @Test\n    public void test() {\n        A a = new A();\n    }\n}</code></pre> <h3 id="静态代码块">静态代码块</h3> <pre><code> 位置：类成员位置，用static修饰的代码块\n\n 作用：对类进行一些初始化  只加载一次，当new多个对象时，只有第一次会调用静态代码块，因为，静态代码块                  是属于类的，所有对象共享一份\n\n 调用: new 一个对象时自动调用\n\n public class 静态代码块 {\n\n@Test\npublic void test() {\n    C c1 = new C();\n    C c2 = new C();\n    //结果,静态代码块只会调用一次，类的所有对象共享该代码块\n    //一般用于类的全局信息初始化\n    //静态代码块调用\n    //代码块调用\n    //构造方法调用\n    //代码块调用\n    //构造方法调用\n}\n\n}\nclass C{\n    C(){\n        System.out.println(&quot;构造方法调用&quot;);\n    }\n    {\n        System.out.println(&quot;代码块调用&quot;);\n    }\n    static {\n        System.out.println(&quot;静态代码块调用&quot;);\n    }\n}</code></pre><pre><code class="language-java">class TestA {\n    static {\n        System.out.println(&quot;父类中的静态代码块&quot;);\n    }\n\n    {\n        System.out.println(&quot;父类中的构造代码块&quot;);\n    }\n\n    public TestA(){\n        System.out.println(&quot;父类中的构造方法&quot;);\n    }\n}\nclass TestB extends TestA{\n    static {\n        System.out.println(&quot;子类中的静态代码块&quot;);\n    }\n\n    {\n        System.out.println(&quot;子类中的构造代码块&quot;);\n    }\n\n    public TestB() {\n        System.out.println(&quot;子类中的构造方法&quot;);\n    }\n}\n\nclass TestDemo {\n    public static void main(String[] args) {\n        TestB b = new TestB();\n    }\n}\n\n\n执行顺序依次为：\n父类的静态成员和代码块\n子类静态成员和代码块\n父类成员初始化和代码快\n父类构造方法\n子类成员初始化和代码块\n子类构造方法</code></pre> <h1 id="class类的使用">Class类的使用</h1> <p>==Class类 != class== </p> <blockquote> <p>Class类的作用是运行时提供或获得某个对象的类型信息，和C++中的typeid()函数类似。这些信息也可用于反射。</p> </blockquote> <h3 id="如何获得一个class类对象">如何获得一个Class类对象</h3> <p>第一种办法，Class类的forName函数</p> <blockquote> <p>public class shapes{} Class obj= Class.forName(&quot;shapes&quot;); </p> </blockquote> <p> 第二种办法，使用对象的getClass()函数</p> <blockquote> <p>public class shapes{} shapes s1=new shapes(); Class obj=s1.getClass(); Class obj1=s1.getSuperclass();//这个函数作用是获取shapes类的父类的类型</p> </blockquote> <p>第三种办法，使用类字面常量</p> <blockquote> <p>Class obj=String.class; Class obj1=int.class; 注意，使用这种办法生成Class类对象时，不会使JVM自动加载该类（如String类）。==而其他办法会使得JVM初始化该类。==</p> </blockquote> <h1 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h1> <p>==深拷贝和浅拷贝的区别==</p> <blockquote> <p>浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p> <p>深拷贝 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的。</p> </blockquote> <p>那么这两种方式有什么相同和不同呢？</p> <blockquote> <p>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。</p> <p>分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p> <p>而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，</p> <p>填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p> </blockquote> <p>==也就是说，一个对象在浅拷贝以后，只是把对象复制了一份放在堆空间的另一个地方，但是成员变量如果有引用指向其他对象，这个引用指向的对象和被拷贝的对象中引用指向的对象是一样的。当然，基本数据类型还是会重新拷贝一份的。==</p> <h1 id="泛型的使用方式">泛型的使用方式</h1> <p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p> <h1 id="io流面试题">IO流面试题</h1> <h3 id="什么是io流？">什么是IO流？</h3> <p>它是一种数据的流从源头流到目的地。比如文件拷贝，输入流和输出流都包括了。输入流从文件中读取数据存储到进程(process)中，输出流从进程中读取数据然后写入到目标文件。</p> <h3 id="字节流和字符流的区别。">字节流和字符流的区别。</h3> <p>==字节流通常处理二进制数据，字符流通常处理文本数据==</p> <p>字节流在JDK1.0中就被引进了，用于操作包含ASCII字符的文件。JAVA也支持其他的字符如Unicode，为了读取包含Unicode字符的文件，JAVA语言设计者在JDK1.1中引入了字符流。ASCII作为Unicode的子集，对于英语字符的文件，可以可以使用字节流也可以使用字符流。</p> <h3 id="java中流类的超类主要由那些？">Java中流类的超类主要由那些？</h3> <p>java.io.InputStream java.io.OutputStream java.io.Reader java.io.Writer</p> <h3 id="fileinputstream和fileoutputstream是什么？">FileInputStream和FileOutputStream是什么？</h3> <p>这是在拷贝文件操作的时候，经常用到的两个类。在处理小文件的时候，它们性能表现还不错，在大文件的时候，最好使用BufferedInputStream (或 BufferedReader) 和 BufferedOutputStream (或 BufferedWriter)</p> <h3 id="systemoutprintln是什么？">System.out.println()是什么？</h3> <p>println是PrintStream的一个方法。out是一个静态PrintStream类型的成员变量，System是一个java.lang包中的类，用于和底层的操作系统进行交互。</p> <h3 id="什么是filter流？">什么是Filter流？</h3> <p>Filter Stream是一种IO流主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能。</p> <h3 id="有哪些可用的filter流？">有哪些可用的Filter流？</h3> <p>在java.io包中主要由4个可用的filter Stream。两个字节filter stream，两个字符filter stream. 分别是FilterInputStream, FilterOutputStream, FilterReader and FilterWriter.这些类是抽象类，不能被实例化的。</p> <h3 id="在文件拷贝的时候，那一种流可用提升更多的性能？">在文件拷贝的时候，那一种流可用提升更多的性能？</h3> <p>==字节流，使用BufferedInputStream和BufferedOutputStream。== </p> <p>==字符流，使用BufferedReader 和 BufferedWriter==</p> <h3 id="说说管道流piped-stream">说说管道流(Piped Stream)</h3> <p>有四种管道流， PipedInputStream, PipedOutputStream, PipedReader 和 PipedWriter.在多个线程或进程中传递数据的时候管道流非常有用。</p> <h3 id="说说file类">说说File类</h3> <p>它不属于 IO流，也不是用于文件操作的，它主要用于知道一个==文件的====属性，读写权限，大小等信息。==</p> <h3 id="说说randomaccessfile">说说RandomAccessFile?</h3> <p>它在java.io包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是Object的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是RandomAccessFile既可以读文件，也可以写文件。 DataInputStream 和 DataOutStream有的方法，在RandomAccessFile中都存在。</p> <h2 id="java多线程面试题">Java多线程面试题</h2> <blockquote> <p><strong>1、多线程有什么用？</strong></p> </blockquote> <p><strong>1）发挥多核CPU的优势</strong></p> <p><strong>2）防止阻塞</strong></p> <p><strong>3）便于建模</strong></p> <p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p> <blockquote> <p><strong>2、创建线程的方式</strong></p> </blockquote> <p>比较常见的一个问题了，一般就是两种：</p> <p>1）继承Thread类</p> <p>2）实现Runnable接口</p> <p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心。</p> <blockquote> <p><strong>3、start()方法和run()方法的区别</strong></p> </blockquote> <p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p> <blockquote> <p><strong>4、Runnable接口和Callable接口的区别</strong></p> </blockquote> <p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p> <p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</p> <p>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p> <p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p> <blockquote> <p><strong>5、CyclicBarrier和CountDownLatch的区别</strong></p> </blockquote> <p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p> <p>1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。</p> <p>2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。</p> <ol> <li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。</li> </ol> <blockquote> <p><strong>6、volatile关键字的作用</strong></p> </blockquote> <p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，</p> <p>1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。</p> <p>2）代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是<strong>Java代码--&gt;字节码--&gt;根据字节码执行对应的C/C++代码--&gt;C/C++代码被编译成汇编语言--&gt;和硬件电路交互</strong>，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。</p> <p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger，更多详情请点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483916&amp;idx=1&amp;sn=89daf388da0d6fe40dc54e9a4018baeb&amp;chksm=eb53873adc240e2cf55400f3261228d08fc943c4f196566e995681549c47630b70ac01b75031&amp;scene=21#wechat_redirect">这里</a>进行学习。</p> <h2 id="7、什么是线程安全"><strong>7、什么是线程安全</strong></h2> <p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p> <p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p> <p><strong>1）不可变</strong></p> <p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p> <p><strong>2）绝对线程安全</strong></p> <p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p> <p><strong>3）相对线程安全</strong></p> <p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p> <p><strong>4）线程非安全</strong></p> <p>这个就没什么好说的了，==ArrayList、LinkedList、HashMa==p等都是线程非安全的类，点击<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486446&amp;idx=2&amp;sn=cb4f3aff0427c5ac3ffe5b61e150f506&amp;chksm=eb538ed8dc2407ceb91fffe3c3bd559d9b15537446f84eb3bfb1a80e67f5efee176ca468a07b&amp;scene=21#wechat_redirect">这里</a>了解为什么不安全。</p> <h3 id="117-有哪些集合是线程不安全的？怎么解决呢？"><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=_117-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F">1.1.7. 有哪些集合是线程不安全的？怎么解决呢？</a></h3> <p>我们常用的 <code>Arraylist</code> ,<code>LinkedList</code>,<code>Hashmap</code>,<code>HashSet</code>,<code>TreeSet</code>,<code>TreeMap</code>，<code>PriorityQueue</code> 都不是线程安全的。解决办法很简单，可以使用线程安全的集合来代替。</p> <p>如果你要使用线程安全的集合的话， <code>java.util.concurrent</code> 包中提供了很多并发容器供你使用：</p> <ol> <li><code>ConcurrentHashMap</code>: 可以看作是线程安全的 <code>HashMap</code></li> <li><code>CopyOnWriteArrayList</code>:可以看作是线程安全的 <code>ArrayList</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>.</li> <li><code>ConcurrentLinkedQueue</code>:高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li> <li><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li> <li><code>ConcurrentSkipListMap</code> :跳表的实现。这是一个<code>Map</code>，使用跳表的数据结构进行快速查找。</li> </ol> <blockquote> <p><strong>8、Java中如何获取到线程dump文件</strong></p> </blockquote> <p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p> <p>1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p> <p>2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p> <p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p> <blockquote> <p><strong>9、一个线程如果出现了运行时异常会怎么样</strong></p> </blockquote> <p>如果这个异常没有被捕获的话，这个线程就停止执行了。</p> <p>另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p> <blockquote> <p><strong>10、如何在两个线程之间共享数据</strong></p> </blockquote> <p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p> <blockquote> <p><strong>11、sleep方法和wait方法有什么区别</strong></p> </blockquote> <p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p> <blockquote> <p><strong>12、生产者消费者模型的作用是什么</strong></p> </blockquote> <p>这个问题很理论，但是很重要：</p> <p>1）<strong>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</strong>，这是生产者消费者模型最重要的作用</p> <p>2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p> <blockquote> <p><strong>13、ThreadLocal有什么用</strong></p> </blockquote> <p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p> <blockquote> <p><strong>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong></p> </blockquote> <p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p> <blockquote> <p><strong>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong></p> </blockquote> <p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器</strong>。</p> <blockquote> <p><strong>16、为什么要使用线程池</strong></p> </blockquote> <p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。点击<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483824&amp;idx=1&amp;sn=7e34a3944a93d649d78d618cf04e0619&amp;scene=21#wechat_redirect">这里</a>学习线程池详解。</p> <blockquote> <p><strong>17、怎么唤醒一个阻塞的线程</strong></p> </blockquote> <p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p> <blockquote> <p><strong>18、不可变对象对多线程有什么帮助</strong></p> </blockquote> <p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p> <blockquote> <p><strong>19、什么是多线程的上下文切换</strong></p> </blockquote> <p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p> <blockquote> <p><strong>20、线程类的构造方法、静态块是被哪个线程调用的</strong></p> </blockquote> <p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p> <p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p> <p>1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p> <p>2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p> <blockquote> <p><strong>21、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</strong></p> </blockquote> <p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p> <p>1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p> <p>2）并发不高、任务执行时间长的业务要区分开看：</p> <p>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p> <p>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p> <p>c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p> <h1 id="java-并发基础常见面试题总结">Java 并发基础常见面试题总结</h1> <h2 id="进程私有：程序计数器，虚拟机栈，本地方法栈">进程私有：程序计数器，虚拟机栈，本地方法栈</h2> <p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p> <p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p> <hr> <h3 id="堆和方法区：">堆和方法区：</h3> <p>堆是存放新建创建的对象，</p> <p>方法区：存放已被加载的类的信息、常量、静态变脸等；</p> <h3 id="并发和并行的区别：">并发和并行的区别：</h3> <p>并发：同一时间，多个任务同时执行（单位时间，多个任务不一定同时执行）</p> <p>并行：单位时间，多个任务同时执行</p> <h1 id="mysql">MySQL</h1> <h2 id="join关键字">JOIN关键字</h2> <blockquote> <p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p> </blockquote> <ul> <li><code>JOIN</code>: 如果表中有至少一个匹配，则返回行</li> <li><code>INNER JOIN</code>:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</li> <li><code>LEFT JOIN</code>: 即使右表中没有匹配，也从左表返回所有的行</li> <li><code>RIGHT JOIN</code>: 即使左表中没有匹配，也从右表返回所有的行</li> <li><code>FULL JOIN</code>: 只要其中一个表中存在匹配，就返回行</li> </ul> <h2 id="mysql-基本架构概览">MySQL 基本架构概览</h2> <ul> <li><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p> </li> <li><p><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p> </li> <li><p><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p> <blockquote> <p>1.词法分析</p> <p>2.语法分析</p> </blockquote> </li> <li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p> </li> <li><p><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</p> </li> </ul> <h2 id="总结">总结</h2> <ul> <li>查询语句的执行流程如下：权限校验（如果命中缓存）---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎</li> <li>更新语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log(prepare 状态---》binlog---》redo log(commit状态)</li> </ul> <h1 id="操作系统">操作系统</h1> <h2 id="死锁的产生条件">死锁的产生条件</h2> <ol> <li>互斥条件：该资源任意一个时刻只由一个线程占用。（互斥）</li> <li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（占有并等待）</li> <li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。（非抢占）</li> <li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。（循环等待）</li> </ol> <h1 id="spring相关">Spring相关</h1> <h2 id="controller--restcontroller">Controller &amp; RestController</h2> <p><strong><code>Controller</code> 返回一个页面</strong></p> <p><strong><code>@RestController</code> 返回JSON 或 XML 形式数据</strong></p> <p><strong><code>@Controller +@ResponseBody</code> 返回JSON 或 XML 形式数据</strong>（@Controller<code>+</code>@ResponseBody<code>=</code>@RestController）</p> <h2 id="spring-ioc--aop">Spring IOC &amp; AOP</h2> <h3 id="ioc">IOC</h3> <p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong> <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong></p> <h3 id="aop">AOP</h3> <p><strong>为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p> <p><strong>Spring AOP就是基于动态代理的</strong>如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：<img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200823230032734.png" alt="image-20200823230032734"></p> <p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p> <h3 id="spring-aop-和-aspectj-aop-有什么区别？">Spring AOP 和 AspectJ AOP 有什么区别？</h3> <p><strong>Spring AOP： 属于运行时增强，基于Proxy</strong></p> <p><strong>而 AspectJ ：是编译时增强。 基于字节码操作(Bytecode Manipulation)。</strong></p> <p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p> <p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多</p> <h2 id="spring-bean的作用域">Spring Bean的作用域</h2> <ol> <li>Singleton 单例</li> <li>Prototype:多例</li> <li>Request:适用于Http request</li> <li>session：适用于HttpSession</li> <li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义</li> </ol> <h2 id="spring中单例bean的线程安全问题：">Spring中单例Bean的线程安全问题：</h2> <p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的<strong>非静态成员变量的写操作</strong>会存在线程安全问题。</p> <p>常见的有两种解决办法：</p> <ol> <li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li> <li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li> </ol> <h3 id="component-和-bean-的区别是什么？">@Component 和 @Bean 的区别是什么？</h3> <ol> <li><p>作用对象不同：</p> <pre><code>&gt;@compontent:作用于类\n   &gt;\n   &gt;@bean：作用于方法</code></pre></li> <li><p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</p> </li> <li><p><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p> </li> </ol> <h3 id="将一个类声明为spring的-bean-的注解有哪些">将一个类声明为Spring的 bean 的注解有哪些?</h3> <p>一般使用@Autowired自动配置Bean，若想实现可通过下面的注解实现</p> <ul> <li>@Component：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li> <li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li> <li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li> <li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li> </ul> <h1 id="分层设计">分层设计</h1> <h2 id="spring-mvc三层设计：">Spring MVC三层设计：</h2> <ul> <li>Model</li> <li>View</li> <li>Controller</li> </ul> <h2 id="java-web">Java Web</h2> <ul> <li><p>表现层</p> </li> <li><p>业务层：server层</p> </li> <li><p>持久层：Dao层</p> </li> <li><p>域模型层：Domain层</p> </li> </ul> <h1 id="jvm虚拟内存模型">JVM虚拟内存模型</h1> <p>总结：JVM 内存模型是什么？ （1）JVM 内存模型共分为5个区：Java虚拟机栈、本地方法栈、堆、程序计数器、方法区（元空间） （2）各个区各自的作用： a.本地方法栈：用于管理本地方法的调用，里面并没有我们写的代码逻辑，其由native修饰，由 C 语言实现。 b.程序计数器：它是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、线程恢复等都依赖于计数器。 c.方法区（Java8叫元空间）：用于存放已被虚拟机加载的类信息，常量，静态变量等数据。 d.Java 虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。（栈里面存的是地址，实际指向的是堆里面的对象） e.堆：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存； （3）线程私有、公有 a.线程私有：每个线程在开辟、运行的过程中会单独创建这样的一份内存，有多少个线程可能有多少个内存 Java虚拟机栈、本地方法栈、程序计数器是线程私有的 b.线程全局共享的 堆和方法区 （4）栈虽然方法运行完毕了之后被清空了，但是堆上面的还没有被清空，所以引出了GC（垃圾回收），不能立马删除，因为不知道是否还有其它的也是引用了当前的地址来访问的</p> <hr> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200910173522831.png" alt="image-20200910173522831"></p> <p><strong>程序计数器</strong>：是一块较小的内存空间、程序执行的字节码指示器；程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。</p> <p>生命周期与线程的生命周期相同</p> <hr> <p><strong>Java虚拟机栈</strong>：生命周期与线程相同；每个方法被执行，Java虚拟机都会创建一个帧栈，用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<strong>局部变量存放的是Java虚拟机基本数据类型</strong>（Boolean、byte、char、short等）和对象引用类型（reference）和returnAddress; 执行Java方法（也就是字节码服务）<strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p> <ul> <li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li> <li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li> </ul> <p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p> <hr> <p><strong>本地方法栈</strong>：虚拟机使用到的本地方法服务（Native）；和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p> <hr> <p><strong>Java堆</strong>：（Java Heap）是虚拟机管理内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。用于存放对象实例；“几乎”所有的对象都在这里分配内存。（所有对象实例及数组都应该在堆上进行分配内存）</p> <p>​ Java堆是垃圾收集管理的内存区域，也被称作“GC堆”Garbage Collected Heap</p> <hr> <p><strong>运行时常量池</strong>：类的版本、字段、方法、接口等描述信息外，还存放了常量池表（Constant Pool Table）用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p> <p><strong><em>直接内存</em></strong>：不是虚拟机运行时数据区的一部分，受物理内存、SWAP分区或者分页大小、以及处理器寻址空间的限制</p> <hr> <h2 id="对象的创建">对象的创建</h2> <h2 id="gc回收">GC回收</h2> <h1 id="mysql-1">MySQL</h1> <h4 id="myisam和innodb区别"><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL?id=myisam%E5%92%8Cinnodb%E5%8C%BA%E5%88%AB">MyISAM和InnoDB区别</a></h4> <p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p> <p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p> <p><strong>两者的对比：</strong></p> <ol> <li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li> <li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li> <li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li> <li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href="https://segmentfault.com/a/1190000012650596">MySQL-InnoDB-MVCC多版本并发控制</a></li> <li>......</li> </ol> ';n.exports=t},5319:function(n,e,t){"use strict";var o=t("d784"),r=t("825a"),a=t("7b0b"),i=t("50c4"),p=t("a691"),s=t("1d80"),c=t("8aa5"),g=t("14c3"),l=Math.max,u=Math.min,d=Math.floor,m=/\$([$&'`]|\d\d?|<[^>]*>)/g,h=/\$([$&'`]|\d\d?)/g,f=function(n){return void 0===n?n:String(n)};o("replace",2,(function(n,e,t,o){var C=o.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,b=o.REPLACE_KEEPS_$0,y=C?"$":"$0";return[function(t,o){var r=s(this),a=void 0==t?void 0:t[n];return void 0!==a?a.call(t,r,o):e.call(String(r),t,o)},function(n,o){if(!C&&b||"string"===typeof o&&-1===o.indexOf(y)){var a=t(e,n,this,o);if(a.done)return a.value}var s=r(n),d=String(this),m="function"===typeof o;m||(o=String(o));var h=s.global;if(h){var S=s.unicode;s.lastIndex=0}var w=[];while(1){var k=g(s,d);if(null===k)break;if(w.push(k),!h)break;var A=String(k[0]);""===A&&(s.lastIndex=c(d,i(s.lastIndex),S))}for(var q="",x=0,D=0;D<w.length;D++){k=w[D];for(var T=String(k[0]),E=l(u(p(k.index),d.length),0),R=[],I=1;I<k.length;I++)R.push(f(k[I]));var P=k.groups;if(m){var M=[T].concat(R,E,d);void 0!==P&&M.push(P);var j=String(o.apply(void 0,M))}else j=v(T,d,E,R,P,o);E>=x&&(q+=d.slice(x,E)+j,x=E+T.length)}return q+d.slice(x)}];function v(n,t,o,r,i,p){var s=o+n.length,c=r.length,g=h;return void 0!==i&&(i=a(i),g=m),e.call(p,g,(function(e,a){var p;switch(a.charAt(0)){case"$":return"$";case"&":return n;case"`":return t.slice(0,o);case"'":return t.slice(s);case"<":p=i[a.slice(1,-1)];break;default:var g=+a;if(0===g)return e;if(g>c){var l=d(g/10);return 0===l?e:l<=c?void 0===r[l-1]?a.charAt(1):r[l-1]+a.charAt(1):e}p=r[g-1]}return void 0===p?"":p}))}}))},"550d":function(n,e){var t='<h1 id="spring-boot入门">Spring Boot入门</h1> <h2 id="1springboot简介">1.SpringBoot简介</h2> <blockquote> <p>简化SPring开发的一个框架；</p> <p>整合Spring技术栈的一个大集合</p> <p>J2EE开发的一站式解决方案</p> </blockquote> <h2 id="微服务">微服务</h2> <p>微服务是一种架构风格</p> <p>一个应用应该是一组小型服务：可以通过HTTP的方式进行互通</p> <p>每一个功能元素最终都是一个可独立替换和升级的软件单元</p> <p><a href="https://www.martinfowler.com/articles/microservices.html">微服务文档</a></p> <h1 id="spring-boot-helloworld">Spring Boot HelloWorld</h1> <p>1.创建Maven 工程</p> <p>2.导入相关依赖</p> <pre><code class="language-xml">&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;</code></pre> <p>3.主程序启动SpringBoot</p> <pre><code class="language-Java">@SpringBootApplication\npublic class HelloWorldMainApplication {\n    public static void main(String[] args) {\n        //启动\n        SpringApplication.run(HelloWorldMainApplication.class,args);\n    }\n}</code></pre> <p>4编写相关的Controller、、、</p> <pre><code class="language-Java">@Controller\npublic class HelloController {\n\n    @ResponseBody\n    @RequestMapping(&quot;/hello&quot;)\n    public String hello(){\n        return &quot;Hello World&quot;;\n    }\n}</code></pre> <p>5.运行主程序测试</p> <p>6.简化部署</p> <pre><code class="language-xml">    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;</code></pre> <p>将这个应用打包成Jar包，直接使用-java -jar运行</p> <h1 id="springboot配置文件">SpringBoot配置文件</h1> <p>​ SpringBoot使用一个全局配置文件</p> <p>​ application.properties</p> <p>​ application.yml</p> <p>作用：修改Spring Boot的默认值；</p> <p>YAML：一个标记语言</p> <p>标记语言：以前大多数配置文件都是 xxx.xml文件</p> <p>以数据为中心，比Json\\xml等更适合做配置文件</p> <h3 id="1三种配置方式">1.三种配置方式</h3> <p>xml配置方式：</p> <pre><code class="language-xml">&lt;server&gt;\n    &lt;port&gt;8081&lt;/port&gt;\n&lt;/server&gt;</code></pre> <p>application.properties配置方式</p> <pre><code class="language-properties">server.port=8081</code></pre> <p>application.yml配置方式</p> <pre><code class="language-yaml">server:\n  port: 8081</code></pre> <h3 id="2yaml语法">2.YAML语法</h3> <h4 id="1基本语法：">1.基本语法：</h4> <p>K: v：表示一对键值对(必须有空格)</p> <p>以<strong>空格</strong>的缩进来控制层级的关系；只要左对齐的一列数据，都是同一个层级的</p> <pre><code class="language-yml">server:\n  port:8080\n  path:/hello</code></pre> <p>属性和值大小写敏感</p> <h4 id="2值的写法字面量">2.值的写法字面量</h4> <p><strong>（数字，字符串，布尔）</strong></p> <p>​ K:v：字面直接来写</p> <p>​ 字符串默认不加单引号或双引号</p> <p>​ &quot;&quot;：双引号会转义字符串里面的特殊字符</p> <p>​ name:&quot;zhangsan \\n lisi&quot; 输出：zhangsan 换行 lisi</p> <p>​ &#39;&#39;：单引号不会转义特殊字符</p> <p>​ name:&quot;zhangsan \\n lisi&quot; 输出：zhangsan \\n lisi</p> <p><strong>对象，Map（属性和值）（键值对）</strong></p> <p>​ 对象还是k:v的值</p> <pre><code class="language-yaml">friends:\n    lastname:zhangsan\n    age:20</code></pre> <p>行内写法</p> <pre><code>friends:{lastName:zhangsan,age:20}</code></pre><p><strong>数组（List Set）</strong></p> <p>用值表示数组中的一个元素</p> <pre><code class="language-yaml">pets:\n- cat\n- dog\n- pig</code></pre> <p>行内写法</p> <pre><code class="language-yaml">pets:[cat,dog,pig]</code></pre> <h4 id="3配置文件注入">3.配置文件注入</h4> <p>配置文件：</p> <pre><code class="language-yaml">server:\n  port: 8081\n\nperson:\n   lastName: zhangsan\n   age: 18\n   boss: false\n   birth: 2017/12/12\n   maps: {k1: v1,k2: v2}\n   lists:\n     - lisi\n     - zhaoliu\n   dog:\n     name: 小狗\n     age: 2</code></pre> <p>JavaBean:</p> <pre><code class="language-java">@Component\n@ConfigurationProperties(prefix = &quot;person&quot;)\npublic class Person {\n\n     /**\n      * @description: 把每一个属性的值映射到组件中\n      */\n    private String lastName;\n    private Integer age;\n    private Boolean boss;\n    private Date birth;\n\n    private Map&lt;String ,Object &gt; maps;\n    private List&lt;Object&gt;lists;\n    private Dog dog;\n</code></pre> <p>我们可以导入配置文件处理器。以后编写配置文件就有提示了</p> <pre><code class="language-xml">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;</code></pre> <h4 id="两种注解的比较">两种注解的比较</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816000153150.png" alt="image-20200816000153150"></p> <h1 id="propertysourceimportresource">@PropertySource&amp;@ImportResource</h1> <p>@PropertySource：加载指定的配置文件</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816225818485.png" alt="image-20200816225818485"></p> <p>@ImportResource：导入Spring的配置文件，让配置文件内的内容生效</p> <p>SpringBoot里面没有Spring的配置文件。我们自己写的配置文件，也不能自动识别</p> <p>想让Spring的配置文件生效，加载进来；<strong>@ImportResource</strong>标注在一个<strong>配置类</strong>上</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816230827053.png" alt="image-20200816230827053"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816230924331.png" alt="image-20200816230924331"></p> <p>SptringBoot推荐给容器中添加组建的方式：推荐使用全注解方式</p> <p>1.配置类====Spring配置文件</p> <p>2.使用@Bean给容器添加组件</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200816231834694.png" alt="image-20200816231834694"></p> <h1 id="配置文件占位符">配置文件占位符</h1> <h2 id="1、随机数">1、随机数</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817113435140.png" alt="image-20200817113435140"></p> <h2 id="2占位符获取之前配置的值，如果没有可以设置默认值">2.占位符获取之前配置的值，如果没有可以设置默认值</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817113548183.png" alt="image-20200817113548183"></p> <h1 id="profile">Profile</h1> <h2 id="1多profile文件">1.多Profile文件</h2> <p>我们在配置文件编写的时候，文件名可以是<strong>application-{profile}.properties/yml</strong></p> <p>默认使用application.properties</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817114905310.png" alt="image-20200817114905310"></p> <h2 id="2yml支持多文档块方式">2.yml支持多文档块方式</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817115454532.png" alt="image-20200817115454532"></p> <h2 id="3激活指定profile">3.激活指定Profile</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817114925425.png" alt="image-20200817114925425"></p> <p>1.在配置文件中指定 spring.profiles.cative=dev</p> <p>2.命令行:</p> <p>​ <strong>--spring.profiles.active=dev</strong></p> <p>打包后的命令行</p> <p><strong>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod</strong></p> <p>可以直接在测试时，传入命令行参数</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817115817429.png" alt="image-20200817115817429"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817120220370.png" alt="image-20200817120220370"></p> <p>3.虚拟机参数</p> <p><strong>-Dspring.profiles.active=dev</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817120505331.png" alt="image-20200817120505331"></p> <h1 id="配置文件加载位置（优先级）">配置文件加载位置（优先级）</h1> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817171214218.png" alt="image-20200817171214218"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818175136302.png" alt="image-20200818175136302"></p> <p>优先级由高到低，高优先级配置会覆盖低优先级的配置；</p> <p>SpringBoot会从这四个位置全部加载主配置文件：<strong>互补配置</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817171943050.png" alt="image-20200817171943050"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817172015097.png" alt="image-20200817172015097">、</p> <p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p> <p>项目打包后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200817172748534.png" alt="image-20200817172748534"></p> <h1 id="自动配置原理">自动配置原理</h1> <p><strong>自动配置原理</strong></p> <p>1）SpringBoot启动的时候加载主配置类，开启了自动配置功能<strong>@EnableAutoConfiguration</strong></p> <p>2)@EnableAutoConfiguration作用：</p> <p>​ 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p> <p>​ 可以插件selectImports()的内容 获取候选的配置</p> <pre><code class="language-java"> List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></pre> <p>将类路径下META/INF/spring.factories里面所用EnableAutoConfigration的值加入到容器中</p> <pre><code class="language-properties"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</code></pre> <p>3)每一个这样的类：xxxAutoConfigration类都是容器中的一个组件；都加入到容器中；用他们来做自动配置</p> <p>4)以<strong>HttpEncodingAutoConfiguration</strong>为例解释自动配置原理</p> <pre><code class="language-java">@Configuration(\n    proxyBeanMethods = false\n)   //表示这是一个配置类，和配置文件一样，向容器中添加组件\n@EnableConfigurationProperties({ServerProperties.class}) //启动指定的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中\n@ConditionalOnWebApplication(  //Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；  判断当前应用是否是web应用，如果是当前配置类生效。\n    type = Type.SERVLET\n)\n@ConditionalOnClass({CharacterEncodingFilter.class}) //判断当前项目是否存在这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器\n\n@ConditionalOnProperty( //判断配置文件中是否存在某个配置server.servlet.encoding.enable;如果不存在也为true；\n    //即使不配置为true也默认为生效\n    prefix = &quot;server.servlet.encoding&quot;,\n    value = {&quot;enabled&quot;},\n    matchIfMissing = true\n)\n\n\npublic class HttpEncodingAutoConfiguration {\n\n    //他已经和springBoot的配置文件映射\n    private final Encoding properties;\n    //只有一个油藏构造器的情况下，参数的值从容器中拿\n    public HttpEncodingAutoConfiguration(ServerProperties properties) {\n        this.properties = properties.getServlet().getEncoding();\n    }\n\n\n    @Bean //给容器中添加一个组件；这个组件的某些值需要从properties中获取\n    @ConditionalOnMissingBean\n    public CharacterEncodingFilter characterEncodingFilter() {\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));\n        return filter;\n    }\n}\n</code></pre> <p>根据当前不同的条件判断，决定这个配置类是否生效</p> <p>一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p> <p>5）所有配置文件中能配置的属性都是在xxxProperties类中的封装者；配置文件将能配置什么就可以参照某个功能对应的这个属性类</p> <pre><code class="language-java">@ConfigurationProperties(   //从配置文件中获取指定的值和Bean的属性进行绑定\n    prefix = &quot;server&quot;,\n    ignoreUnknownFields = true\n)</code></pre> <p><strong>精髓：</strong></p> <p>​ <strong>1）SpringBoot启动会加载大量的自动配置类</strong></p> <p>​ <strong>2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</strong></p> <p>​ <strong>3）我们在看这个自动配置类中到底配置了那些组件（只要我们要用到的组件有，我们就不需要再来配置类）</strong></p> <p>​ <strong>4）给容器中自动配置类添加组件的时候，会从Properties类中获取某些属性。我们就可以在配置文件中指定这些属性</strong></p> <p>xxxAutoConfigurartion：自动配置类</p> <p>给容器中添加组件</p> <p>xxxProperties：封装配置文件中相关属性；</p> <h2 id="细节："><strong>细节</strong>：</h2> <p>@Conditional：条件为true则像容器中添加组件，配置里面的所有内容才生效</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818190716900.png" alt="image-20200818190716900"></p> <p><strong>自动配置类必须在一定条件下才能生效</strong></p> <p>我们怎么知道那些自动配置类生效</p> <p>启动Debug=ture属性让控制台打印报告，我们就可以很方便的知道那些配置类生效</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818191548079.png" alt="image-20200818191548079"></p> <h1 id="spring-boot与日志">Spring Boot与日志</h1> <h1 id="日志">日志</h1> <h2 id="1日志框架">1.日志框架</h2> <p>底层是SpringBoot；底层是Spring框架，Spring框架默认用的是JCL</p> <p> <strong>SpringBoot选用SLF4和logback</strong></p> <h2 id="2slfj的使用">2.SLFj的使用</h2> <h3 id="1如何在系统中使用slf4j">1.如何在系统中使用SLF4j</h3> <p>开发的时候，日志记录方法的调用，不应该来直接俄调用日志的实现类，而是调用日志抽象层的方法：</p> <p>给系统里面导入slf4j的Jar和logback的实现Jar </p> <pre><code class="language-java">import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(&quot;Hello World&quot;);\n  }</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819230535396.png" alt="image-20200819230535396"></p> <p>每一个日志的实现框架都有自己的配置文件，使用slf4j以后<strong>，配置文件还是做成日志实现框架自己本身的配置文件</strong></p> <h3 id="2依赖框架">2.依赖框架</h3> <p>a（slf4j+logback）：Spring（commons-logging）Hibernate(jboss-logging) </p> <p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819231517927.png" alt="image-20200819231517927"></p> <p><strong>==如何让系统中所有的日志统一到dslf4j？</strong>==</p> <ol> <li>==将系统中其他日志框架先排除出去：==</li> <li>==用中间包来替换原有的日志框架；==</li> <li>==导入slf4j其他的实现==</li> </ol> <h2 id="3spring-boot日志关系">3.Spring Boot日志关系</h2> <pre><code class="language-xml">    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;</code></pre> <p>​ SpringBoot使用它来</p> <pre><code class="language-xml">    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n      &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n      &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;/dependency&gt;</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819232853247.png" alt="image-20200819232853247"></p> <p>总结：</p> <p>1）SB底层也是使用slf4j+logback的记录方式进行日志记录</p> <p>2) SB也把其他的日志都替换成了slf4j</p> <p>3) 中间替换包</p> <p>4）如果要引入其他框架，一定要把这个框架的默认依赖移除掉</p> <p>​ SP使用的是commons-logging</p> <p>SP能自动适配所有的日志，而且底层使用slf4j_logback的方式记录日志，引入其他框架的时候自动排出</p> <h2 id="4日志使用；">4.日志使用；</h2> <h3 id="1默认配置">1.默认配置</h3> <p>​ SP默认配置好了日志；</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235036010.png" alt="image-20200819235036010"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235053431.png" alt="image-20200819235053431"></p> <h4 id="loggingfilename">Logging.file.name</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235804460.png" alt="image-20200819235804460"></p> <h4 id="loggingfilepath">Logging.file.path</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200819235712590.png" alt="image-20200819235712590"></p> <h4 id="loggingpatternfile---loggingpatternconsole">Logging.pattern.file &amp; Logging.pattern.console</h4> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200820000418187.png" alt="image-20200820000418187"></p> <h1 id="四、web开发">四、Web开发</h1> <p>使用SB开发</p> <p>1）创建项目应用选中所需要的组件</p> <p>2）SB默认配置好场景，只需要在配置文件中指定少量配置就可以运行起来</p> <p>3）自己编写业务代码</p> <p>自动配置原理：</p> <h1 id="五、整合数据库">五、整合数据库</h1> <h2 id="1整合druid">1.整合Druid</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201004002500755.png" alt="image-20201004002500755"></p> <pre><code class="language-yaml">spring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://localhost:3306/plant\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\n    initiaSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n    filters: stat,wall,log4j\n    MaxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    ConnectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</code></pre> <p>config/DruidConfig</p> <pre><code class="language-java">\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)\n    @Bean\n    public DataSource druid() {\n        return new DruidDataSource();\n    }\n\n    //配置监控\n    //1. 管理后台的Servlet\n\n    @Bean\n    public ServletRegistrationBean statViewServlet() {\n        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);\n        Map&lt;String, String&gt; initMaps = new HashMap&lt;&gt;();\n\n        initMaps.put(&quot;loginUsername&quot;, &quot;admin&quot;);\n        initMaps.put(&quot;loginPassword&quot;, &quot;admin&quot;);\n        // 不写允许所有\n        initMaps.put(&quot;allow&quot;, &quot;&quot;);\n\n        bean.setInitParameters(initMaps);\n        return bean;\n    }\n\n    //2. 配置Filtter\n    public FilterRegistrationBean WebStatFilter() {\n        FilterRegistrationBean bean = new FilterRegistrationBean();\n        bean.setFilter(new WebStatFilter());\n\n        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();\n        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);\n        bean.setInitParameters(initParams);\n\n        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));\n        return bean;\n    }\n}</code></pre> <h2 id="2整合mybatis">2.整合Mybatis</h2> <h3 id="配置druid">配置Druid</h3> <h3 id="配置mybatis驼峰命名">配置MyBatis驼峰命名</h3> <p>路径在/config/MyBatisConfig</p> <pre><code class="language-java">@org.springframework.context.annotation.Configuration\npublic class MyBatisConfig {\n\n    @Bean\n    public ConfigurationCustomizer configurationCustomizer() {\n        return new ConfigurationCustomizer() {\n            @Override\n            public void customize(Configuration configuration) {\n                configuration.setMapUnderscoreToCamelCase(true);\n            }\n        };\n    }\n}\n</code></pre> <pre><code class="language-Java">使用MapperScan批量扫描Mapper所有的接口\n@MapperScan(value = &quot;com.atfuigu.springboot06mybatis.mapper&quot;)</code></pre> <p>xml文件使用驼峰命名</p> <pre><code class="language-xml">resources/mybatis/mybatis-config.xml\n\n&lt;configuration&gt;\n    &lt;settings&gt;\n        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;</code></pre> ';n.exports=t},"590a":function(n,e){var t='<h1 id="swagger-editor和swagger-ui的搭建">swagger-editor和swagger-ui的搭建</h1> <h1 id="1swagger-editor">1.swagger-editor</h1> <p>0.前提：安装了nodejs和npm</p> <p>1.先安装http-server(-g 表示全局安装)</p> <pre><code class="language-shell">npm install -g http-server</code></pre> <p>2.获取并解压源码</p> <pre><code class="language-shell">wget https://github.com/swagger-api/swagger-editor/releases/download/v2.10.4/swagger-editor.zip\nunzip swagger-editor.zip</code></pre> <p>3.使用http-server启动</p> <pre><code class="language-shell">http-server swagger-editor #默认端口8080\nhttp-server –p 8081 swagger-editor  #更换端口为8081</code></pre> <p>启动成功：</p> <pre><code class="language-shelll">Starting up http-server, serving swagger-editor\nAvailable on:\n  http://127.0.0.1:8081\n  http://192.168.0.79:8081\nHit CTRL-C to stop the server</code></pre> <p><img src="%5Cimages%5Cswagger_demo.png" alt=""></p> <h1 id="2swagger-ui">2.swagger-ui</h1> <p>两种方式：A.扩展版，B.官方版</p> <h5 id="a扩展版使用tomcat">A.扩展版(使用Tomcat)</h5> <p>1.在<a href="http://www.sosoapi.com/">sosoapi</a>注册，登录后下载SwaggerUI扩展版</p> <p>2.根据sosoapi官方的部署说明安装(其实就是部署到Tomcat)</p> <p>3.启动Tomcat，访问：<a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/">http://localhost:8080/项目名/</a></p> <p>将编辑好的API json文档放在项目的json文件夹下(yml格式的可放在yml文件夹下，归类清晰)，在界面导航栏中访问文件即可： <a href="http://localhost:8080/swagger/yml/123.yml">http://localhost:8080/swagger/yml/123.yml</a> 或 <a href="http://localhost:8080/swagger/json/123.json">http://localhost:8080/swagger/json/123.json</a></p> <p>另外，sosoapi提供了表单式的编辑API方式，与swagger-editor直接编辑yml的方式相比，更简单点。</p> <h5 id="b官方版">B.官方版</h5> <ul> <li>1.下载<a href="https://github.com/swagger-api/swagger-ui">github源码</a></li> </ul> <pre><code class="language-shell">git clone https://github.com/swagger-api/swagger-ui</code></pre> <ul> <li>2.进入项目，都是静态文件，浏览器中打开dist文件夹下的index.html，即可看到UI界面(走file协议)，其中的json是官方的例子：<a href="%5Bhttp://petstore.swagger.io/v2/swagger.json%5D(http://petstore.swagger.io/v2/swagger.json?_ga=2.162860479.2022098243.1523439613-583979946.1523439613)">Swagger Petstore</a></li> <li>3.将swagger-ui项目部署到http-server服务器中，使用http协议访问。因为之前是全局安装的http-server，所以在swagger-ui所在的文件夹打开终端，直接启动即可：</li> </ul> <pre><code class="language-undefined">http-server –p 8082 swagger-ui</code></pre> <ul> <li>4.修改官方默认展示的文档json 打开swagger-ui/dist中的index.html，修改url指向自己json/yml文件夹下的文档json/yml文件</li> </ul> ';n.exports=t},"593c":function(n,e){var t='<h1 id="npucraft-新手安装游玩">NPUcraft 新手安装游玩</h1> <p><strong>前言：</strong>此教程适合之前从未接触过的玩家参考</p> <h2 id="1-下载">1. 下载</h2> <p><strong>QQ群：598445021</strong> </p> <p>群文件——小鹿课堂——下载最新的整合包</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921092648199.png" alt="image-20200921092648199"></p> <h2 id="2-解压压缩包">2. 解压压缩包</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093230332.png" alt="image-20200921093230332"></p> <p>​ <strong>打开解压后的文件夹</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093315931.png" alt="image-20200921093315931"></p> <h2 id="3-安装jre">3. 安装JRE</h2> <p>运行 jre-8u261-windows-x64</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093434715.png" alt="image-20200921093434715"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093449364.png" alt="image-20200921093449364"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093522078.png" alt="image-20200921093522078"></p> <p><strong>等待安装ing</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093703974.png" alt="image-20200921093703974"></p> <p><strong>安装完成</strong></p> <h2 id="4启动游戏">4.启动游戏</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921093800020.png" alt="image-20200921093800020"></p> <h2 id="41-设置账户">4.1 设置账户</h2> <h3 id="411-有正版账户">4.1.1 有正版账户</h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094112213.png" alt="image-20200921094112213"></p> <h3 id="412-无正版账户">4.1.2 无正版账户</h3> <p>​ <img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094321714.png" alt="image-20200921094321714"></p> <h2 id="42-进入游戏">4.2 进入游戏</h2> <p><strong>创建账户完成后</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094950647.png" alt="image-20200921094950647"></p> <p><strong>选择游戏版本</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094630976.png" alt="image-20200921094630976"></p> <p><strong>启动游戏</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094501329.png" alt="image-20200921094501329"></p> <p><strong>等待启动</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921094700673.png" alt="image-20200921094700673"></p> <h2 id="5-选择个人-or-服务器">5. 选择个人 or 服务器</h2> <p><strong><em>背景可能有所不同</em></strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921095221917.png" alt="image-20200921095221917"></p> <h3 id="51选择服务器">5.1选择服务器</h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921095720218.png" alt="image-20200921095720218"></p> <h3 id="52加入服务器">5.2加入服务器</h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921095758865.png" alt="image-20200921095758865"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921095812951.png" alt="image-20200921095812951"></p> <h3 id="53注册账户">5.3注册账户</h3> <p><strong>图中密码仅为示例，请不要设置过于简单</strong></p> <p><strong>输入后，回车即可</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921100140520.png" alt="image-20200921100140520"></p> <h4 id="531超时错误">5.3.1超时错误</h4> <p><strong>入如果手速输入太慢，就会超时；出现如下界面。重新进入服务器即可</strong></p> <h3 id="54-注册成功">5.4 注册成功</h3> <p><strong>如果最下边对话框消失，说明注册成功。。。你就可以愉快的游玩了</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921100538223.png" alt="image-20200921100538223"></p> <h2 id="6-退出游戏">6. 退出游戏</h2> <p><strong>按下 ESC 键后选择断开连接就好了</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921100738362.png" alt="image-20200921100738362"></p> <h2 id="7-下次登录">7. 下次登录</h2> <p><strong>下次登录时，依然将输入法设置为英文状态，</strong></p> <p><strong>出现对话框后，输入/login &lt;密码&gt;</strong> </p> <p><strong>输入完毕回车即可</strong></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200921100849776.png" alt="image-20200921100849776"></p> ';n.exports=t},"5cd4":function(n,e){var t='<p>[TOC]</p> <h1 id="spring-farmwork">Spring Farmwork</h1> <h1 id="官网：">官网：</h1> <blockquote> <p>Spring.io</p> </blockquote> <h1 id="spring-是什么：">Spring 是什么：</h1> <blockquote> <p>Spring是分层的Java SE/EE应用<font color="red">full-stack</font>轻量级开源框架</p> </blockquote> <h1 id="spring的两大核心：">Spring的两大核心：</h1> <p><font color="red">IOC（反转控制）</font> </p> <blockquote> <p><font color="red">削减耦合</font>，降低依赖关系(把创建对象的权力交给框架或者工厂)</p> </blockquote> <p><font color="red">AOP（面向切面编程）</font>为内核，提供展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</p> <h1 id="创建bean的三种方式">创建Bean的三种方式</h1> <p>创建Bean的三种方式:</p> <p>第一种方式：使用默认构造函数创建。 在Spring的配置文件中使用Bean标签，配以ID和CLASS属性之后，且没有其他属性和标签时 采用的就是默认构造函数创建Bean对象，此时如果类中没有构造函数，则对象无法创建</p> <pre><code class="language-xml"> &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</code></pre> <p>第二种方式：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入Spring容器）</p> <pre><code class="language-xml">     &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;\n\n    &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre> <p>第三种方法： 使用工厂中的静态方法创建对象，(使用某个类中的静态方法创建对象，并存入Spring容器)</p> <pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</code></pre> <h1 id="bean的作用范围">Bean的作用范围</h1> <p>Bean标签的Scope属性:</p> <pre><code>作用：用于指定Bean的作用范围\n取值：\nsingleton : 单例的（默认值）\nprototype :多例的\nrequest   :作用域Web应用的请求范围\nsession   :作用域Web应用的会话范围\nglobal-session：作用域集群环境的会话范围（全局会话范围），不是集群环境时，他就是Session</code></pre><pre><code class="language-xml"> &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\n</code></pre> <h1 id="bean对象的生命周期">Bean对象的生命周期</h1> <pre><code>单例对象：\n    出生：容器创建出生\n    活着：只要容器在，对象一直存活\n    死亡：容器消失，对象消亡\n    总结：单例对象的生命周期和容器相同\n多例对象：\n    出生：使用对象时，Spring创建\n    活着：对象在使用过程中，一直活着\n    死亡：当对象长时间不用，且没有其他对象引用时由Java垃圾回收机制回收；</code></pre><h1 id="spring的依赖注入">Spring的依赖注入</h1> <ol> <li><p>Spring中的依赖注入 Dependency Injection IOC的作用：降低耦合（依赖关系） 依赖关系的管理：以后交给Spring维护 在当前类需要用到其他类的对象，由Spring为我们提供。我们只需要在配置文件中 说明</p> </li> <li><p>依赖关系的维护： 就称之为依赖注入 依赖注入：</p> <blockquote> <p>​ 能注入的数据：有三类 ​ 1.基本类型和String</p> <p>​ 2.其他的Bean类型</p> <p>​ 3.复杂类型/集合类型</p> <p> 注入的方式有三种：</p> <p>​ 1.第一种：使用构造函数提供</p> <p>​ 2.第二种：使用set方法提供</p> <p>​ 3.第三种：使用注解提供</p> </blockquote> </li> </ol> <h2 id="构造函数注入：">构造函数注入：</h2> <p>第一种：构造函数注入 constructor-arg 在Bean标签的内部使用</p> <pre><code class="language-xml">&lt;bean&gt;\n&lt;constructor-arg&gt;\n&lt;/bean&gt;</code></pre> <p>属性：</p> <blockquote> <p>type：用于指定要注入的数据的数据类型 index：用于指定要注入的数据给构造函数的索引位置 name:用于指定给构造函数中指定名称的参数赋值</p> </blockquote> <p><font color="red">以上三个用于指定给构造函数中哪个参数赋值</font></p> <hr> <blockquote> <p>value:用于提供基本类型过和String类型的数据</p> <p>ref : 用于指定其他的Bean类型数据。在Spring的IOC核心容器中出现过的Bean对象</p> </blockquote> <p>总结：</p> <blockquote> <p>优势： 在获Bean对象时，注入是必须的操作，否则无法创建成功 弊端： 该拜年了Bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据也必须提供</p> </blockquote> <pre><code class="language-xml">    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;\n        &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt;\n        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;\n        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;/bean&gt;\n\n    &lt;!--    配置一个日期--&gt;\n    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;\n\n</code></pre> <h2 id="set注入">Set注入</h2> <p>涉及的标签：property</p> <p>出现的位置：Bean标签的内部</p> <p>标签的属性：</p> <blockquote> <p>name:用于指定注入时所调用的set方法名称；</p> <p>value:用于提供基本类型过和String类型的数据</p> <p>ref : 用于指定其他的Bean类型数据。在Spring的IOC核心容器中出现过的Bean对象</p> </blockquote> <p>总结：</p> <blockquote> <p>优势：</p> <p>​ 创建时有明确的限制，可以直接使用默认构造函数</p> <p>弊端：</p> <p>​ 如果有某个成员必须有值，则获取对象有可能Set方法没有执行</p> </blockquote> <pre><code class="language-xml">    &lt;!--    Set 注入--&gt;\n    &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;特斯拉&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n</code></pre> <h2 id="复杂类型的注入">复杂类型的注入</h2> <p>用于给List集合注入的标签：list array set</p> <p>用于给Map结构集合注入的标签：map props</p> <p>结构相同，标签可以互换</p> <h1 id="注解：">注解：</h1> <p>XML文件配置：</p> <pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;\n\n* 用于创建对象过的注解\n    在XML配置文件中编写一个&lt;bean&gt;表爱去哪实现功能是一样的\n     @Component:\n        作用：把当前类对象存入Spring容器中\n        属性：value用于指定Bean的id。不写时默认值为当前类名，且首字母小写\n   @Controller    ：用于表现层\n   @Service      ：用于业务层\n   @Respository    ：用于持久层\n        以上三个注解，他们的作用和属性与Compontent是一模一样的，\n        是Spring框架为我们提供明确的三层使用的注解，是我们的三层对象更加清晰\n* 用于注入数据的        \n        在XML配置中的bean中写一个&lt;property&gt;标签一样\n   @Autowired:\n        作用：自动按照类型注入，只要容器中有唯一的一个Bean对象类型和要注入的变量类型匹配，就可以注入成功；\n              如果IOC容器中没有任何Bean的类型和要注入的变量类型匹配，则报错\n              如果有多个类型匹配时\n        出现位置：可以是变量上，可以是方法上\n        细节：在使用注解时,set方法就可以不用\n   @Qualified：必须依赖于Autowired\n        作用：在按按照而理性注入的基础上再按照名称注入。它在给类成员注入时不能单独使用；但给参数注入时可以\n           属性：value：用于指定注入bean的ID\n   @Resource\n        作用：直接按照bean的ID注入，可以单独使用\n        属性：\n              name:用于指定bean的ID\n           以上三个注解，只能注入其他Bean类型的术后据，而基本类型和String类型无法使用上述注解实现。\n        另外，类型集合的注入只能通过XML实现\n\n\n   @Value：\n        作用：用于注入基本类型和String类型\n        属性：value：用于指定数据的值，可以使用Spring中SpEL（Spring中的el表达式）\n             SpEL写法：${表达式}\n* 改变作用范围的\n        作用集合在bean标签中使用scop标签是一样的\n   @Scope \n        作用：用于指定Bean的作用范围\n        属性：\n            Value：指定范围的取值，Singleton、Prototype\n* 生命周期相关（了解）\n        作用和bean标签中使用init-method,destroy-method\n   @PreDestroy：\n           指定销毁方法\n  @ PostContruct：\n        指定初始化方法\n</code></pre> <h1 id="configration注解：">Configration注解：</h1> <pre><code class="language-xml">@Configuration    \n    作用：\n        指定当前类是一个配置类\n    细节：\n        1.当配置类作为AnnotationCondifApplicationContext对象创建时，该注解可不写\n        2.\n@ComponentsScan：\n    作用：\n        用于指定Spring创建容器时所需要扫描的包\n    属性：\n        value:它和basePackkages的作用是一样的，都是指定窗户将容器时所要扫描的包\n              此注解等同与在XML中配置了&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;\n@Bean:\n    作用：\n        把当前方法的返回值作为Bean对象存入Spring容器中\n    属性：\n        naem:用于指定bean的ID，不写诗，默认值为当前方法的名称\n    细节：\n        当使用注解配置方法时，如果方法有参数，Spring框架会去容器中查找有没有可用的Bean对象，查找的方式和Autowied一致\n@Import\n    作用：用于导入其它的配置类\n    属性：\n        value:用于指定其他配置类的字节码\n              放我们使用Import注释的是父配置类，而导入的是子配置类\n@PropertySource :\n        作用：用于指定Peoperties文件的位置\n属性：values:指定文件路径和名册和名称\n        关键字classpath</code></pre> <h1 id="spring-test注解">Spring Test注解</h1> <pre><code class="language-java">\n\n@Runwith\n        :提供一个注解，把原有的main方法替换了，替换成Spring提供的\n\n@ContextConfigration\n        ：location：指定xml位置，加上class path关键字，表示在类路径下（@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)\n）\n        classes：指定注解类所在位置</code></pre> <h1 id="aop">AOP</h1> <h2 id="实例分析：">实例分析：</h2> <p>解决多个进程问题，无法回滚</p> <h2 id="动态代理对象">动态代理对象</h2> <h3 id="demo基于接口的动态代理">Demo:基于接口的动态代理</h3> <blockquote> <pre><code>   动态代理\n\n   特点：字节码随用随创建、加载\n       不修改源码的基础上对方法进行增强\n   分类：\n\n           基于接口的动态代理\n           基于子类的动态代理\n\n           基于接口的动态代理：\n                   涉及的类Proxy\n                   提供者：JDK官方\n            如何创建代理对象：\n                   使用Proxy类中的 newProxyInstance\n            创建代理对象的要求：\n                   被代理类最少实现一个接口，如果没有则不能使用\n           newProxyInstance方法的参数：\n                   ClassLoader : 用于加载对象字节码。和被代理对象使用相同的类加载器；固定写法\n                   Class[]：         让代理对象和被代理对象有相同的方法。固定写法\n                   InvocationHandle：  让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类；但不是必须的\n            此接口的实现类都是谁用谁写</code></pre></blockquote> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200811222212008.png" alt="image-20200811222212008"></p> <h3 id="demo基于子类的动态代理">Demo:基于子类的动态代理</h3> <blockquote> <pre><code>   动态代理\n\n   特点：字节码随用随创建、加载\n       不修改源码的基础上对方法进行增强\n   分类：\n\n   ​    基于接口的动态代理\n   ​    基于子类的动态代理\n\n   基于子类的动态代理：\n            涉及的类:Enhancer\n           提供者：第三方 cglib\n    如何创建代理对象：\n           使用Proxy类中的 Ehancer类中的Create方法\n    创建代理对象的要求：\n           被代理类不能是最终类\n   cerate方法的参数：\n           Class：字节码，用于指定被代理对象的字节码\n           Callback：  让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类；但不是必须的\n   ​    此接口的实现类都是谁用谁写\n   ​    我们一般写的都是该接口的子接口实现类:MethodInterceptor</code></pre></blockquote> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200811224451387.png" alt="image-20200811224451387"></p> <h2 id="aop概念及作用">AOP概念及作用</h2> <p>AOP：面向切面编程，是OOP的延续，是函数式编程的延续</p> <p>作用：在程序运行期间，不修改源码对已有方法进行增强</p> <p>优势：</p> <p>​ 减少重复代码</p> <p>​ 提高开发效率</p> <p>​ 维护方便</p> <h3 id="通知的类型：">通知的类型：</h3> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813155631126.png" alt="image-20200813155631126"></p> <h1 id="spring基于xml的aop配置步骤">Spring基于XML的AOP配置步骤</h1> <p>​ 1.把通知的Bean交给Logger来管理 ​ 2.使用AOP：config标签表示开始AOP的配置 ​ 3.使用Aop：aspect标签表明配置切面： ​ id属性：给切面提供一个唯一标志 ​ ref属性：指定通知类的Bean ID ​ 4.在aop:aspect内部使用对应标签来配置通知的类型 ​ aop:before 配置前置通知 ​ method属性：用于指定Logger类中哪个方法作为前置通知 ​ pointcut属性：用于指定切入点表达式。对业务层哪些方法进行增强</p> <p>​ 切入点从表达式的写法： ​ 关键字：execution(表达式) ​ 表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表） ​ 标准的表达式写法:public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813163613547.png" alt="image-20200813163613547"></p> <pre><code class="language-xml">&lt;!--    配置Spring的IOC，把service对象配置进来--&gt;\n&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;\n\n&lt;!--    Spring基于XML的AOP配置步骤\n    1.把通知的Bean交给Logger来管理\n    2.使用AOP：config标签表示开始AOP的配置\n    3.使用Aop：aspect标签表明配置切面：\n            id属性：给切面提供一个唯一标志\n            ref属性：指定通知类的Bean ID\n     4.在aop:aspect内部使用对应标签来配置通知的类型\n            aop:before 配置前置通知\n                method属性：用于指定Logger类中哪个方法作为前置通知\n                pointcut属性：用于指定切入点表达式。对业务层哪些方法进行增强\n\n             切入点从表达式的写法：\n             关键字：execution(表达式)\n             表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）\n              标准的表达式写法:public void com.itheima.service.impl.AccountServiceImpl.saveAccount()\n--&gt;\n&lt;!--    配置Logger类--&gt;\n&lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;\n&lt;!--配置AOP--&gt;\n&lt;aop:config&gt;\n    &lt;!--        配置切面--&gt;\n    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;\n        &lt;!--            配置通知的类型并且建立通知方法和切入点方法的关联--&gt;\n        &lt;aop:before method=&quot;printLog&quot;\n                    pointcut=&quot;execution(public void com.itheima.service.impl.AccountServiceImpl.saveAccount())&quot;&gt;&lt;/aop:before&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;</code></pre> <h3 id="通配表达式的写法">通配表达式的写法</h3> <pre><code>             切入点从表达式的写法：\n             关键字：execution(表达式)\n             表达式：访问修饰符 返回值 包名.包名.类名.方法名（参数列表）\n              标准的表达式写法:&lt;font color=red&gt;public void com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                  访问修饰符可以省略：\n                        &lt;font color=red&gt;void com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                  返回值可以使用*，表示任意返回值\n\n                    *   &lt;font color=red&gt;com.itheima.service.impl.AccountServiceImpl.saveAccount()&lt;/font&gt;\n                                      包名可以使用通配符，表示任意包，但是有几级包就需要写几个*.\n\n                                           * *.*.*.*.AccountServiceImpl.saveAccount()\n                                                                  包名可以使用..表示当前包及其子包\n                                                                       * *..AccountServiceImpl.saveAccount();\n                                                                                         类名和方法名都可以使用*通配\n\n                                                                                                   * *..*.*()\n                                                                                                                参数列表：\n                                                可以直接写数据类型：\n                                            基本类型直接写名称 int\n                                                              应用类型写包名.类名方式 java.lang.String\n                                                                                                                                    可以使用通配符表示任意类型，但必须有参数，\n                                                                                                                          可以使用..表示有无参数均可，有参数可以是任意类型\n                                                                                  全通配写法：* *..*.*(..)</code></pre><p> <font color="red">实际开发中通常写法：切到业务层实现类的所有方法: </font></p> <p>​ <font color="red"> * com.itheima.service.impl.<em>.</em>(..) </font></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813170532038.png" alt="image-20200813170532038"></p> <h2 id="环绕通知的写法：">环绕通知的写法：</h2> <pre><code>/**\n * 问题：\n * 当配置了环绕通知后，切入点方法没有执行，而通知方法执行了\n * 分析：\n * 通过对比动态代理中的环绕通知代码，发现动态代理中的环绕通知有明确的切入点调用方法，而我们代码中没有\n * 解决：\n * Spring框架为我们提供一个接口：ProceedingJoinPoint，该接口有一个方法Proceed（）。此方法明确调用切入点方法\n * 该接口可以作为环绕方法的通知参数，在程序执行时，Spring框架会为我们提供该接口方法的实现类供我们使用\n *\n * Spring环绕通知\n *      他是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式\n **/</code></pre><p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813175349451.png" alt="image-20200813175349451"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813175330483.png" alt="image-20200813175330483"></p> <h2 id="注解通知：">注解通知：</h2> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181443487.png" alt="image-20200813181443487"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181513663.png" alt="image-20200813181513663"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200813181530691.png" alt="image-20200813181530691"></p> <h1 id="spring中基于xml的声明式事务控制配置">Spring中基于XML的声明式事务控制配置</h1> <p>​ 1.配置事务管理器 ​ 2.配置事务的通知，需要约束,同时也需要AOP ​ 属性：</p> <p>​ id 给事务通知一个标识 ​ transaction-manager：给事务管理器通知提供一个事务管理器的引用 ​ 3.配置AOP通用切入点表达式 ​ 4.建立事务通知和表达式的关系 ​ 5.配置事务的属性: ​ 是在事务通知的tx:advice标签内部 ​ isolation=&quot;&quot; : 用于指定事务的隔离界别，默认值default表示使用数据库的级别 ​ propagation=&quot;&quot; ：用于指定十五点额传播行为，默认值时REQUIRED，表示一定有事务，增删改的选择。查询方法可以选择 SUPPORT ​ read-only=&quot;&quot;：用于指定事务是否支付，只有查询方法才能设置为True默认值为false，表示为可读写 ​ timeout=&quot;&quot;：事务的超时时间，默认值-1.永不超时；若指定了数值，以秒为单位 ​ rollback-for=&quot;&quot;：用于指定一个异常；但产生异常时；事务回滚；产生其它异常时，事务不回滚没有默认值。表示人任何异常都回 滚 ​ no-rollback-for=&quot;&quot; ：用于指定一个异常，但产生该异常时事务不回滚。产生其他异常时事务会回滚，没有默认值表示任何异常都 回滚</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814224346045.png" alt="image-20200814224346045"></p> <h1 id="spring中基于aopl的声明式事务控制配置">Spring中基于AOPL的声明式事务控制配置</h1> <p>​ 1.配置事务管理器 ​ 2.开启Spring对注解事务的支持 ​ 3.在需要事务支持的地方使用@Transactionz注解</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814225219908.png" alt="image-20200814225219908"></p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200814225246382.png" alt="image-20200814225246382"></p> ';n.exports=t},"60c9":function(n,e,t){},"647b":function(n,e){var t='<h1 id="一、基础知识">一、基础知识</h1> <p>不同的服务模块架构在不同的服务器上，</p> <p><strong>RPC:</strong> 远程过程调用</p> <p>分布式服务框架（RPC）,是一种进程通信工具 </p> <p>RPC 的两大核心：模块化、序列化</p> ';n.exports=t},6547:function(n,e,t){var o=t("a691"),r=t("1d80"),a=function(n){return function(e,t){var a,i,p=String(r(e)),s=o(t),c=p.length;return s<0||s>=c?n?"":void 0:(a=p.charCodeAt(s),a<55296||a>56319||s+1===c||(i=p.charCodeAt(s+1))<56320||i>57343?n?p.charAt(s):a:n?p.slice(s,s+2):i-56320+(a-55296<<10)+65536)}};n.exports={codeAt:a(!1),charAt:a(!0)}},6598:function(n,e){var t='<h1 id="openfans-os">OpenFans OS</h1> <p>OpenFans 默认提供用户名为： <code>pi</code> 密码为：<code>raspberry</code></p> <p>理页面，<code>http://[树莓派ip地址]:9000</code></p> <p>raspberry</p> <pre><code>1.Web可视化管理界面\n登录地址 https://你树莓派的IP地址:9090\n说明：请使用系统默认账户pi登录\n\n2.WEB SSH 客户端 入口界面\n登录地址 https://你树莓派的IP地址:4200\n说明：使用具有控制台登录权限的帐户登录，例如：pi\n\n3.CecOS CaaS 容器云管理平台 登录界面\n登录地址 https://你树莓派的IP地址:8443\n说明：默认管理账户 admin , 默认密码：password 。请登录后立即修改默认密码！！</code></pre><p>OpenFans 还会默认安装一个 CecOS 容器云平台，帮助我们提供界面化管理 Docker 容器的管理平台。</p> <p>默认的地址是：<code>http://[树莓派ip地址]:8443</code>，默认的用户名为：<code>admin</code>，默认的密码为：<code>password</code>。</p> <p>ע���룺FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6</p> ';n.exports=t},"6a0b":function(n,e){var t='<h1 id="token">Token</h1> <h2 id="验证流程">验证流程</h2> <p><img src="http://images2015.cnblogs.com/blog/34831/201606/34831-20160622152259735-1969767936.jpg" alt="img"></p> <h2 id="请求认证">请求认证</h2> <p><img src="http://images2015.cnblogs.com/blog/34831/201606/34831-20160622152344250-1238130627.jpg" alt="img"></p> <p><strong><em>对Token认证机制有5点直接注意的地方：</em></strong></p> <ul> <li><strong><em>一个Token就是一些信息的集合；</em></strong></li> <li><strong><em>在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</em></strong></li> <li><strong><em>服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；</em></strong></li> <li><strong><em>基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；</em></strong></li> <li><strong><em>因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；</em></strong></li> </ul> ';n.exports=t},"6c63":function(n,e){var t='<h1 id="spring-security-oauth-20-认证授权"><strong>Spring Security OAuth 2.0 认证授权</strong></h1> <h2 id="1基于session的认证流程">1.基于Session的认证流程</h2> ';n.exports=t},"6fca":function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"markdown_style",staticStyle:{"font-family":"'DejaVu Sans Mono'","text-align":"left","font-size":"20px"},attrs:{id:"doc"},domProps:{innerHTML:n._s(n.msg)}})},r=[],a=(t("d3b7"),{name:"DocumentSpringCloud",data:function(){return{md:"",msg:"",key:0}},methods:{testMd:function(n){var e=this;t("dcab")("./"+n+".md").then((function(n){e.msg=n.default})),this.key+=1}},mounted:function(){var n=this.$route.params.id;this.testMd(n)}}),i=a,p=(t("7dff"),t("2877")),s=Object(p["a"])(i,o,r,!1,null,"594020b4",null);e["default"]=s.exports},"774d":function(n,e){var t="";n.exports=t},7823:function(n,e,t){"use strict";t("60c9")},"7b25":function(n,e){var t='<h1 id="ssh框架的构建">SSH框架的构建</h1> <h2 id="1引入spring">1.引入Spring</h2> <ol> <li>导入jar包</li> <li></li> </ol> <h2 id="2引入hibernate">2.引入Hibernate</h2> <h2 id="建立持久化类">建立持久化类</h2> <p>Spring整合Hibernate</p> <h2 id="3引入struts">3.引入Struts</h2> <h2 id="4完成功能">4.完成功能</h2> ';n.exports=t},"7b54":function(n,e,t){"use strict";t("abfd")},"7bbe":function(n,e,t){n.exports=t.p+"img/github.85f8d56b.png"},"7dff":function(n,e,t){"use strict";t("27fb")},"80b4":function(n,e){var t='<h1 id="spring-boot-starter-data-jpa">Spring-Boot-Starter-Data-JPA</h1> <h2 id="1、引入spring-boot-starter-data-jpa">1、引入Spring-Boot-Starter-Data-JPA</h2> <p>JPA:ROM </p> <h2 id="2、配置文件打印sql语句">2、配置文件打印SQL语句</h2> <h2 id="3、创建entity标注jpa注解">3、创建Entity标注JPA注解</h2> <h2 id="4、创建repository家口继承jpa-repository">4、创建Repository家口继承JPA Repository</h2> <h2 id="5、测试方法">5、测试方法</h2> <h2 id="例子">例子</h2> <ol> <li><p>编写一个实体类（bean)</p> <pre><code class="language-java">/**\n * @author 79443\n * 使用JPA注释配置映射关系\n */\n\n@Entity  // 告诉JPA这是一个实体类\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Integer id;\n\n    @Column\n    private String username;\n\n    @Column\n    private String userpwd;\n\n    @Column\n    private String sex;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getUserpwd() {\n        return userpwd;\n    }\n\n    public void setUserpwd(String userpwd) {\n        this.userpwd = userpwd;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n}</code></pre> </li> </ol> <ol start="2"> <li><p>创建一个Repository来实现实体类对应的数据表</p> <pre><code class="language-java">/**\n * @author 79443\n * 继承JpRepository来完成对数据库的操作\n */\npublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; {\n\n}</code></pre> </li> </ol> <ol start="3"> <li><p>基本的JPA Properties</p> <pre><code class="language-yaml">spring:\n  jpa:\n    hibernate:\n#      更新或者创建表结构    \n      ddl-auto: update\n#      控制台显示SQl\n    show-sql: true</code></pre> </li> </ol> ';n.exports=t},"898f":function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"divBackground"},[t("div",{staticStyle:{width:"fit-content","margin-left":"35%"}},n._l(n.list,(function(e){return t("span",{key:e,staticStyle:{width:"30%"}},[t("el-card",{attrs:{id:e},nativeOn:{click:function(t){return n.docSkip(e)}}},[n._v(" "+n._s(e)+" ")]),t("br")],1)})),0)])},r=[],a=(t("d3b7"),t("ac1f"),t("5319"),t("ddb0"),{name:"DocumentList",components:{},data:function(){return{list:Array}},methods:{docSkip:function(n){this.$router.push("/list/"+n),console.log(n)}},mounted:function(){for(var n=t("ccc4").keys(),e=[],o=0;o<n.length;o++){var r=n[o];r=r.replace("./",""),r=r.replace(".md",""),e.push(r)}this.list=e}}),i=a,p=t("2877"),s=Object(p["a"])(i,o,r,!1,null,"1daf0896",null);e["default"]=s.exports},"8aa5":function(n,e,t){"use strict";var o=t("6547").charAt;n.exports=function(n,e,t){return e+(t?o(n,e).length:1)}},9263:function(n,e,t){"use strict";var o=t("ad6d"),r=t("9f7fd"),a=RegExp.prototype.exec,i=String.prototype.replace,p=a,s=function(){var n=/a/,e=/b*/g;return a.call(n,"a"),a.call(e,"a"),0!==n.lastIndex||0!==e.lastIndex}(),c=r.UNSUPPORTED_Y||r.BROKEN_CARET,g=void 0!==/()??/.exec("")[1],l=s||g||c;l&&(p=function(n){var e,t,r,p,l=this,u=c&&l.sticky,d=o.call(l),m=l.source,h=0,f=n;return u&&(d=d.replace("y",""),-1===d.indexOf("g")&&(d+="g"),f=String(n).slice(l.lastIndex),l.lastIndex>0&&(!l.multiline||l.multiline&&"\n"!==n[l.lastIndex-1])&&(m="(?: "+m+")",f=" "+f,h++),t=new RegExp("^(?:"+m+")",d)),g&&(t=new RegExp("^"+m+"$(?!\\s)",d)),s&&(e=l.lastIndex),r=a.call(u?t:l,f),u?r?(r.input=r.input.slice(h),r[0]=r[0].slice(h),r.index=l.lastIndex,l.lastIndex+=r[0].length):l.lastIndex=0:s&&r&&(l.lastIndex=l.global?r.index+r[0].length:e),g&&r&&r.length>1&&i.call(r[0],t,(function(){for(p=1;p<arguments.length-2;p++)void 0===arguments[p]&&(r[p]=void 0)})),r}),n.exports=p},9516:function(n,e,t){n.exports=t.p+"img/gmail.964b840e.png"},"9f7fd":function(n,e,t){"use strict";var o=t("d039");function r(n,e){return RegExp(n,e)}e.UNSUPPORTED_Y=o((function(){var n=r("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=o((function(){var n=r("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},a608:function(n,e){var t='<h2 id="1两数之和">1.两数之和</h2> <pre><code class="language-java">//给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 \n//\n// 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 \n//\n// \n//\n// 示例: \n//\n// 给定 nums = [2, 7, 11, 15], target = 9\n//\n//因为 nums[0] + nums[1] = 2 + 7 = 9\n//所以返回 [0, 1]\n// \n// Related Topics 数组 哈希表 \n\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int result[] = new int[2];\n        int length = nums.length;\n        Map &lt;Integer , Integer&gt;map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; length; i++) {\n            int key = nums[i];\n            int value = i;\n            int temp = target - key;\n            if(map.containsKey(temp)){\n                result[0] = i;\n                result[1] = map.get(temp);\n                return result;\n            }\n            map.put(key,value);\n        }\n        throw new RuntimeException(&quot;没有符合条件的结果&quot;);\n\n    }\n}\n</code></pre> <h2 id="2两数相加">2.两数相加</h2> <pre><code class="language-java">//给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 \n//\n// 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 \n//\n// 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 \n//\n// 示例： \n//\n// 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n//输出：7 -&gt; 0 -&gt; 8\n//原因：342 + 465 = 807\n// \n// Related Topics 链表 数学 \n// 👍 4853 👎 0\n\n\n//leetcode submit region begin(Prohibit modification and deletion)\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode pre = new ListNode(0);\n        ListNode cur = pre;\n        int carry = 0;\n        while(l1 != null || l2 != null) {\n            int x = l1 == null ? 0 : l1.val;\n            int y = l2 == null ? 0 : l2.val;\n            int sum = x + y + carry;\n\n            carry = sum / 10;\n            sum = sum % 10;\n            cur.next = new ListNode(sum);\n\n            cur = cur.next;\n            if(l1 != null)\n                l1 = l1.next;\n            if(l2 != null)\n                l2 = l2.next;\n        }\n        if(carry == 1) {\n            cur.next = new ListNode(carry);\n        }\n        return pre.next;\n    }\n}\n//leetcode submit region end(Prohibit modification and deletion)\n</code></pre> <h2 id="20有效的括号">20.有效的括号</h2> <pre><code class="language-java">//给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 \n//\n// 有效字符串需满足： \n//\n// \n// 左括号必须用相同类型的右括号闭合。 \n// 左括号必须以正确的顺序闭合。 \n// \n//\n// 注意空字符串可被认为是有效字符串。 \n//\n// 示例 1: \n//\n// 输入: &quot;()&quot;\n//输出: true\n// \n//\n// 示例 2: \n//\n// 输入: &quot;()[]{}&quot;\n//输出: true\n// \n//\n// 示例 3: \n//\n// 输入: &quot;(]&quot;\n//输出: false\n// \n//\n// 示例 4: \n//\n// 输入: &quot;([)]&quot;\n//输出: false\n// \n//\n// 示例 5: \n//\n// 输入: &quot;{[]}&quot;\n//输出: true \n// Related Topics 栈 字符串 \n// 👍 1836 👎 0\n\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public boolean isValid(String s) {\n        Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;();\n        map.put(&#39;)&#39;, &#39;(&#39;);\n        map.put(&#39;]&#39;, &#39;[&#39;);\n        map.put(&#39;}&#39;, &#39;{&#39;);\n\n        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n        for (char ch : s.toCharArray()) {\n            if (ch == &#39;(&#39; || ch == &#39;[&#39; || ch == &#39;{&#39;) {\n                stack.push(ch);\n            }\n            else if (stack.isEmpty() || stack.pop() != map.get(ch)){\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n</code></pre> <h2 id="58最后一个单词的长度">58.最后一个单词的长度</h2> <pre><code class="language-java">//给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 \n//\n// 如果不存在最后一个单词，请返回 0 。 \n//\n// 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。 \n//\n// \n//\n// 示例: \n//\n// 输入: &quot;Hello World&quot;\n//输出: 5\n// \n// Related Topics 字符串 \n// 👍 239 👎 0\n\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int end = s.length() - 1;\n        while (end &gt;= 0 &amp;&amp; s.charAt(end) == &#39; &#39;) {\n            end--;\n        }\n        if (end &lt; 0 ) return 0;\n        int start = end;\n        while (start &gt;= 0 &amp;&amp; s.charAt(start) != &#39; &#39;) {\n            start--;\n        }\n        return end - start;\n    }\n}\n//leetcode submit region end(Prohibit modification and deletion)\n</code></pre> <h2 id="66加一">66.加一</h2> <pre><code class="language-java">//给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 \n//\n// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 \n//\n// 你可以假设除了整数 0 之外，这个整数不会以零开头。 \n//\n// 示例 1: \n//\n// 输入: [1,2,3]\n//输出: [1,2,4]\n//解释: 输入数组表示数字 123。\n// \n//\n// 示例 2: \n//\n// 输入: [4,3,2,1]\n//输出: [4,3,2,2]\n//解释: 输入数组表示数字 4321。\n// \n// Related Topics 数组 \n// 👍 537 👎 0\n\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i &gt;= 0; i--) {\n            digits[i]++;\n            digits[i] = digits[i] % 10;\n            if (digits[i] != 0) return digits;\n        }\n        digits = new int[digits.length + 1];\n        digits[0] = 1;\n        return digits;\n    }\n}\n//leetcode submit region end(Prohibit modification and deletion)\n</code></pre> <h2 id="70爬楼梯">70.爬楼梯</h2> <pre><code class="language-java">/**\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n**/\n\nclass Solution {\n    public int climbStairs(int n) {\n        int sum = 0;\n        int first = 1 , secound = 1;\n        for (int i = 2; i &lt;= n; i++) {\n            sum = first + secound;\n            first = secound;\n            secound = sum;\n        }\n        return secound;\n\n    }\n}</code></pre> <h2 id="136只出现一次的数字">136.只出现一次的数字</h2> <pre><code class="language-java">//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 \n//\n// 说明： \n//\n// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ \n//\n// 示例 1: \n//\n// 输入: [2,2,1]\n//输出: 1\n// \n//\n// 示例 2: \n//\n// 输入: [4,1,2,1,2]\n//输出: 4 \n\nclass Solution{\n     public int singleNumber(int nums[]){\n        int result = 0;\n        for(int num:nums){\n            result ^= num;\n        }\n        return result;\n    }   \n}</code></pre> ';n.exports=t},abfd:function(n,e,t){},ac1f:function(n,e,t){"use strict";var o=t("23e7"),r=t("9263");o({target:"RegExp",proto:!0,forced:/./.exec!==r},{exec:r})},ad6d:function(n,e,t){"use strict";var o=t("825a");n.exports=function(){var n=o(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},ae7c:function(n,e){var t='<h1 id="python">Python</h1> <p>This&#39;s Pyrhon Doc....</p> <h1 id="基础-启航">基础-启航</h1> <h2 id="基本输入输出">基本输入输出</h2> <pre><code class="language-python">print(&quot;&quot;)\n\nvariable = input(&quot;&quot;);  //variable : 自定义变量</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200905230402253.png" alt="image-20200905230402253"></p> <h2 id="注释">注释</h2> <pre><code class="language-python"># 这是一条注释\n\n&quot;&quot;&quot;这是个注释&quot;&quot;&quot;\n&#39;&#39;&#39;这也是条注释&#39;&#39;&#39;\n\n&#39;&#39;&#39;\n这是\n多行\n注释\n&#39;&#39;&#39;</code></pre> <h2 id="运算符">运算符</h2> <pre><code class="language-python">/  #计算为小数\n%  #取证符号\n// #取余\n**  \n&#39;&#39;&#39;\neg:     \n    a=3\n    b = a**2\n    print(b)\n    // b= 9\n&#39;&#39;&#39;</code></pre> <h3 id="逻辑运算符">逻辑运算符</h3> <pre><code class="language-python">and\nor\nnot  # not x 取反，若x为真，则结果为假；</code></pre> <h2 id="循环">循环</h2> <pre><code class="language-python"># while 循环\na = 0\nwhile a &lt; 7 :\n    if a % 2 == 0:\n        print(a,&quot;is even&quot;)\n    else:\n        print(a,&quot;is odd&quot;)\n    a += 1</code></pre> <pre><code class="language-python"># for 循环\n#Demo1 范围循环；for(i=0;i&lt;10;i++)\nfor i in range(0,10):{\n    print(i)\n}\n\n#Demo2 遍历集合\nList = [&quot;Apple&quot;,&quot;Banana&quot;]\nfor i in List:{\n    print(i)\n}\n\n#Demo3 遍历String字符串\nfruits = &quot;There are 4 apples&quot;\nfor i in fruits:{\n    print(i)\n}\n\n</code></pre> <pre><code class="language-python"># 乘法表 9*9\nfor i in range(0,10):\n    for j in range(1,i+1):\n        print(&#39;%d*%d=%d\\t&#39; %(j,i,i*j),end=&#39;&#39;)\n        if i == j:\n            print()</code></pre> ';n.exports=t},af3a:function(n,e,t){n.exports=t.p+"img/wechat.a8fee2c3.png"},bb51:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{staticClass:"divBackground",staticStyle:{"font-family":"'DejaVu Sans Mono'","font-style":"italic"}},[o("h1",[n._v(n._s(n.$t("message.saying")))]),o("el-divider"),o("div",{staticClass:"paragraph",attrs:{id:"info"}},[o("h2",{attrs:{id:"about_me"}},[n._v("About Me")]),o("p",{staticStyle:{margin:"2%"}},[n._v(" "+n._s(n.profession)+" ")]),o("br"),o("el-divider"),n._m(0),o("h3",[n._v("2016-2020")]),o("p",{staticStyle:{margin:"2%"}},[n._v(" School of Computer Science & Technology , Tianjin University of Commerce ,Tianjin , China ")]),o("el-divider"),n._m(1),o("i",{staticClass:"el-icon-message",staticStyle:{"font-family":"'DejaVu Sans Mono'","font-style":"italic"}},[n._v("Email Address : "+n._s(n.Contact.email))]),o("br"),o("br"),o("img",{staticStyle:{height:"20px",width:"20px"},attrs:{src:t("af3a")}}),o("i",[n._v(" WeChat ID:"+n._s(n.Contact.wechat))]),o("el-divider"),n._m(2),n._m(3)],1),n._m(4)],1)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("h2",{attrs:{id:"experience"}},[t("i",{staticClass:"el-icon-info"}),n._v("Experience")])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("h2",{attrs:{id:"Contact"}},[t("i",{staticClass:"el-icon-message"}),n._v("Contact")])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("h2",{attrs:{id:"Links"}},[t("i",{staticClass:"el-icon-share"}),n._v("Links")])},function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{staticStyle:{margin:"2%"},attrs:{id:"links_ico"}},[o("a",{attrs:{href:"https://github.com/WangJiyuanYo"}},[o("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:t("7bbe")}})]),o("a",{attrs:{href:"https://t.me/tokrn"}},[o("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:t("f5f9")}})]),o("a",{attrs:{href:"https://mail.google.com/"}},[o("img",{staticStyle:{width:"4%",height:"4%"},attrs:{src:t("9516")}})])])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("footer",{staticClass:"footer",staticStyle:{"font-family":"Meath"}},[t("div",[n._v(" MIT Licensed | Copyright © 2018-2020 Vue.js ")])])}],a=(t("e4cb"),t("1f64d"),t("3976"),{name:"Home",data:function(){return{saying:"Anything can't kill me , it will make me be better",profession:"Work as Computer Programmer Designer\n",imgSrc:t("cb54"),Contact:{email:" Gwangjiyuan@gmail.com",wechat:"Gwangjiyuan"},user:{},responseResult:{},language:{}}}}),i=a,p=(t("7823"),t("2877")),s=Object(p["a"])(i,o,r,!1,null,"24114cb4",null);e["default"]=s.exports},c305:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("h1",[n._v("404 Not Found")])])}],a={name:"notFound404"},i=a,p=t("2877"),s=Object(p["a"])(i,o,r,!1,null,"32235ab8",null);e["default"]=s.exports},cbfa:function(n,e){var t='<p>[TOC]</p> <h1 id="解决mysql时区问题">解决MySQL时区问题</h1> <p>1.查询时区</p> <pre><code class="language-sql">select timediff(now(),convert_tz(now(),@@session.time_zone,&#39;+00:00&#39;)); \n或者:\n\nSELECT TIMEDIFF(NOW(), UTC_TIMESTAMP); </code></pre> <p>2.修改时区</p> <pre><code class="language-sql">set global time_zone = &#39;+8:00&#39;;  ##修改mysql全局时区为北京时间，即我们所在的东8区\nset time_zone = &#39;+8:00&#39;;  ##修改当前会话时区\nflush privileges;  #立即生效</code></pre> <p>3.JDBC连接数据库时</p> <pre><code>设置SetTimeZone = &quot;Asia/ShangHai&quot;\nGMT\njdbc.url = jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8</code></pre><h2 id="学习笔记：">学习笔记：</h2> <h2 id="sqlmapconfigxml">SqlMapConfig.xml</h2> <p>1.头标签：</p> <pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</code></pre> <h2 id="一级缓存的分析">一级缓存的分析</h2> <p>一级缓存是SqlSession对象的缓存。当SqlSession对象消失时，一级缓存也会消失 </p> <p>一级缓存是Sqlsession 范围的缓存，当调用SqlSession的修改i、添加、删除、commit()、close()、clearCache()；方法的时候会清除一级缓存</p> <h2 id="二级缓存的分析">二级缓存的分析</h2> <p>​ 二级缓存是SqlsessionFactory的对象缓存（存放的是数据），由同一个SqlSessionFactory对象创建对策SqlSession共享其缓存</p> <p>使用步骤：</p> <p>​ 第一步：Mybatis框架支持二级缓存（SqlMapConfig.xml）</p> <p>​ 第二步：让当前因施工和文件支持二级缓存（IUserDao.xml文件中）</p> <p>​ 第三步：让当前操作支持二级缓存（在Select标签中）</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200803224025883.png" alt="image-20200803224025883"></p> <p>调用结果：</p> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200803223903545.png" alt="image-20200803223903545"></p> <h1 id="注解开发">注解开发</h1> <p>在MyBatis中针对CRUD一共有四个注解：@SELECT @INSERT @UPDATE @DELETE</p> <h1 id="mysql语句优化">MySQL语句优化</h1> <h3 id="1-所有表必须使用-innodb-存储引擎">1. 所有表必须使用 Innodb 存储引擎</h3> <p>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。</p> <p>Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p> <h3 id="2-数据库和表的字符集统一使用-utf8">2. 数据库和表的字符集统一使用 UTF8</h3> <p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p> <h3 id="3-所有表和字段都需要添加注释">3. 所有表和字段都需要添加注释</h3> <p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p> <h3 id="4-尽量控制单表数据量的大小建议控制在-500-万以内。">4. 尽量控制单表数据量的大小,建议控制在 500 万以内。</h3> <p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p> <p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p> <h3 id="5-谨慎使用-mysql-分区表">5. 谨慎使用 MySQL 分区表</h3> <p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p> <p>谨慎选择分区键，跨分区查询效率可能更低；</p> <p>建议采用物理分表的方式管理大数据。</p> <h3 id="6尽量做到冷热数据分离减小表的宽度">6.尽量做到冷热数据分离,减小表的宽度</h3> <blockquote> <p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。</p> </blockquote> <p>减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；</p> <p>更有效的利用缓存，避免读入无用的冷数据；</p> <p>经常一起使用的列放到一个表中（避免更多的关联操作）。</p> <h3 id="7-禁止在表中建立预留字段">7. 禁止在表中建立预留字段</h3> <p>预留字段的命名很难做到见名识义。</p> <p>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</p> <p>对预留字段类型的修改，会对表进行锁定。</p> <h3 id="8-禁止在数据库中存储图片文件等大的二进制数据">8. 禁止在数据库中存储图片,文件等大的二进制数据</h3> <p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。</p> <p>通常存储于文件服务器，数据库只存储文件地址信息</p> <h3 id="9-禁止在线上做数据库压力测试">9. 禁止在线上做数据库压力测试</h3> <h3 id="10-禁止从开发环境测试环境直接连接生成环境数据库">10. 禁止从开发环境,测试环境直接连接生成环境数据库</h3> <h1 id="qa">Q&amp;A</h1> <h2 id="一条sql语句执行得很慢的原因有哪些？">一条SQL语句执行得很慢的原因有哪些？</h2> <p>​ 分类讨论：</p> <p>​ 1.大多数情况下正常，偶尔的情况下很慢</p> <p>​ 2.在数据量不变的情况下，一直执行很慢</p> <h3 id="针对偶尔很慢的情况（1）">针对偶尔很慢的情况（1）</h3> <ol> <li><p>数据库在刷新脏页（Flush）</p> <p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</p> <ol> <li><p><strong>redolog满了：</strong> redo log的容量有限，如果数据库一直处于繁忙，更新也很频繁数据库很快就会被写满；数据库只能暂停其他的操作，用来将数据同步到磁盘当中</p> </li> <li><p><strong>内存不够用：</strong> 如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，若此时内存不够就需要释放一些数据页，干净页直接释放；脏页就需要刷新脏页</p> </li> <li><p><strong>MySQL 认为系统“空闲”的时候：</strong>这时系统没什么压力。</p> </li> <li><p><strong>MySQL 正常关闭的时候：</strong>这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p> </li> <li><p>拿不到锁</p> </li> </ol> <p>如果所需要执行的表被其他的操作所上锁，只能在其他操作释放锁后再执行；判断是否在等待可以使用 show processlist查看当前的状态</p> </li> </ol> <h3 id="针对一直比较慢的情况（2）">针对一直比较慢的情况（2）</h3> <pre><code class="language-sql">#案例表\nmysql&gt; CREATE TABLE `t` (\n  `id` int(11) NOT NULL,\n  `c` int(11) DEFAULT NULL,\n  `d` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;</code></pre> <ol> <li><p><strong>没有用到索引：</strong> </p> <p>​ <strong>(1) 字段没有索引</strong></p> <pre><code class="language-sql">select * from t where 100 &lt;c and c &lt; 100000;</code></pre> <p>​ <strong>(2) 字段有索引，却没有用索引(此时，字段C有索引)</strong></p> <pre><code class="language-sql">select * from t where c - 1 = 1000;</code></pre> <pre><code class="language-sql">#正确的操作\nselect * from t where c = 1000 + 1S;</code></pre> <p>​ <strong>(3) 函数操作导致没有用上索引</strong></p> <p>​ </p> <pre><code class="language-sql">select * from t where pow(c,2) = 1000;</code></pre> </li> </ol> <pre><code> 2. 数据库自己选错了索引\n\n ### 总结\n\n ![image-20200914145026526](C:\\Users\\79443\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200914145026526.png)</code></pre>';n.exports=t},ccc4:function(n,e,t){var o={"./Docker.md":"e684","./Dubbo.md":"647b","./Hibernate.md":"eea2","./Lambada.md":"774d","./Leetcode.md":"a608","./MySql.md":"cbfa","./NPUCraft.md":"593c","./Nacos.md":"f8aa","./Python.md":"ae7c","./Raspberry.md":"6598","./SSH框架.md":"7b25","./Spring-JPA.md":"80b4","./Spring.md":"5cd4","./SpringBoot.md":"550d","./SpringSecurityOAuth2.0.md":"6c63","./Swagger.md":"590a","./Token验证.md":"6a0b","./computer.md":"ef4c","./technology.md":"1a30","./vue.md":"0c42","./面经.md":"4bee"};function r(n){var e=a(n);return t(e)}function a(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}r.keys=function(){return Object.keys(o)},r.resolve=a,n.exports=r,r.id="ccc4"},d180:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",{staticClass:"divBackground"},[t("div",{staticStyle:{"margin-left":"5%",width:"15%","margin-top":"5em"},attrs:{id:"timeLine"}},[t("h2",[n._v("博客进展")]),t("Timeline")],1),t("h2",[n._v("TO DO")]),t("el-divider",{staticClass:"divider_class"}),n._m(0)],1)])},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticStyle:{"margin-left":"5%",width:"20%","text-align":"left"},attrs:{id:"TO DO"}},[t("h3",[n._v("添加ME页面内容")]),t("h3",[n._v("添加项目内容")]),t("h3",[n._v("抽离时间栏")]),t("h3",[n._v("抽离Markdown组件")]),t("h3",[n._v("增加en语言")]),t("h3",[n._v("增加平台适配")])])}],a=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"block"},[t("el-timeline",n._l(n.activities,(function(e,o){return t("el-timeline-item",{key:o,attrs:{icon:e.icon,type:e.type,color:e.color,size:e.size,timestamp:e.timestamp}},[n._v(" "+n._s(e.content)+" ")])})),1)],1)},i=[],p={name:"Timeline",data:function(){return{activities:[{content:"开始项目",timestamp:"2020-06-28",size:"large",type:"primary",icon:"el-icon-more"},{content:"构建框架",timestamp:"2020-06-28",color:"#0bbd87"},{content:"导航栏背景",timestamp:"2020-06-30",color:" #0bbd87"},{content:"引入Markdown文件",timestamp:"2020-07-01",color:" #0bbd87"},{content:"修改路由",timestamp:"2020-07-01",color:" #0bbd87"},{content:"Beta 1版本发布",timestamp:"2020-07-04",color:" #0bbd87"},{content:"修改主页内容",timestamp:"2020-07-09",color:"#0bbd87"},{content:"调试后端API",timestamp:"2020-11-22",color:"#0bbd87"},{content:"引入语言切换",timestamp:"2020-11-29",color:"#0bbd87"},{content:"引入自定义字体",timestamp:"2020-12-07",color:"#0bbd87"},{content:"主页语言配置",timestamp:"2020年12月13日",color:"#0bbd87"},{content:"其他待加入",timestamp:"2020-11-22",color:"red"}]}}},s=p,c=t("2877"),g=Object(c["a"])(s,a,i,!1,null,"6ed9d9e0",null),l=g.exports,u=(t("1f64d"),{name:"Other",components:{Timeline:l}}),d=u,m=(t("7b54"),Object(c["a"])(d,o,r,!1,null,"3e32bf9f",null));e["default"]=m.exports},d784:function(n,e,t){"use strict";t("ac1f");var o=t("6eeb"),r=t("d039"),a=t("b622"),i=t("9263"),p=t("9112"),s=a("species"),c=!r((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")})),g=function(){return"$0"==="a".replace(/./,"$0")}(),l=a("replace"),u=function(){return!!/./[l]&&""===/./[l]("a","$0")}(),d=!r((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]}));n.exports=function(n,e,t,l){var m=a(n),h=!r((function(){var e={};return e[m]=function(){return 7},7!=""[n](e)})),f=h&&!r((function(){var e=!1,t=/a/;return"split"===n&&(t={},t.constructor={},t.constructor[s]=function(){return t},t.flags="",t[m]=/./[m]),t.exec=function(){return e=!0,null},t[m](""),!e}));if(!h||!f||"replace"===n&&(!c||!g||u)||"split"===n&&!d){var C=/./[m],b=t(m,""[n],(function(n,e,t,o,r){return e.exec===i?h&&!r?{done:!0,value:C.call(e,t,o)}:{done:!0,value:n.call(t,e,o)}:{done:!1}}),{REPLACE_KEEPS_$0:g,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:u}),y=b[0],v=b[1];o(String.prototype,n,y),o(RegExp.prototype,m,2==e?function(n,e){return v.call(n,this,e)}:function(n){return v.call(n,this)})}l&&p(RegExp.prototype[m],"sham",!0)}},dcab:function(n,e,t){var o={"./Docker.md":"e684","./Dubbo.md":"647b","./Hibernate.md":"eea2","./Lambada.md":"774d","./Leetcode.md":"a608","./MySql.md":"cbfa","./NPUCraft.md":"593c","./Nacos.md":"f8aa","./Python.md":"ae7c","./Raspberry.md":"6598","./SSH框架.md":"7b25","./Spring-JPA.md":"80b4","./Spring.md":"5cd4","./SpringBoot.md":"550d","./SpringSecurityOAuth2.0.md":"6c63","./Swagger.md":"590a","./Token验证.md":"6a0b","./computer.md":"ef4c","./technology.md":"1a30","./vue.md":"0c42","./面经.md":"4bee"};function r(n){return Promise.resolve().then((function(){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}var r=o[n];return t.t(r,7)}))}r.keys=function(){return Object.keys(o)},r.id="dcab",n.exports=r},ddb0:function(n,e,t){var o=t("da84"),r=t("fdbc"),a=t("e260"),i=t("9112"),p=t("b622"),s=p("iterator"),c=p("toStringTag"),g=a.values;for(var l in r){var u=o[l],d=u&&u.prototype;if(d){if(d[s]!==g)try{i(d,s,g)}catch(h){d[s]=g}if(d[c]||i(d,c,l),r[l])for(var m in a)if(d[m]!==a[m])try{i(d,m,a[m])}catch(h){d[m]=a[m]}}}},e4cb:function(n,e,t){},e684:function(n,e){var t='<h1 id="一介绍">一.介绍</h1> <h1 id="二docker的基本操作">二.Docker的基本操作</h1> <h2 id="21安装dockers">2.1安装Dockers</h2> <pre><code class="language-bash">0. sudo apt-get install yum #安装yum命令\nyum -y install yum-utils       #安装工具包</code></pre> <pre><code class="language-bash">#想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样\nyum -y install yum-utils device-mapper-persistent-data lvm2</code></pre> <pre><code class="language-bash"># 1.设置Dockers镜像源\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre> <pre><code class="language-bash"># 4安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker\n#启动docker服务\nsystemctl start docker\n#设置开机自动启动\nsystemctl enable docker\n#测试\ndocker run hello-world</code></pre> <h2 id="22docker的中央仓库">2.2Docker的中央仓库</h2> <pre><code class="language-bash"># 修改配置文件\nvim /etc/docker/daemon.json\n\n{\n    &quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;],\n    &quot;insecure-registries&quot;:[&quot;ip:port&quot;]\n}\n#使用公共仓库\nDOCKER_OPTS=&quot;--registry-mirror=http://yourRegist.m.daocloud.io&quot;\nDOCKER_OPTS=&quot;--registry-mirror=http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&quot;\n#重启两个服务\nsystemctl daemon-reload\nsystemctl restart docker</code></pre> <h3 id="国内可用加速服务">国内可用加速服务</h3> <pre><code class="language-bash">vi /etc/docker/daemon.json</code></pre> <pre><code class="language-bash"># 中科大镜像\n{&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]}\n\n#阿里云镜像\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;\n{\n  &quot;registry-mirrors&quot;: [&quot;https://332attgo.mirror.aliyuncs.com&quot;]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker</code></pre> <pre><code class="language-bash">systemctl daemon-reload\nsystemctl restart docker</code></pre> <h2 id="23镜像的操作">2.3镜像的操作</h2> <pre><code class="language-bash">#1.拉取镜像到本地\ndocker pull 镜像名称[:tag]\n#例子\ndocker pull daocloud.io/library/nginx:latest  #拉取Nginx</code></pre> <pre><code class="language-bash">#2.查看本地全部镜像\ndocker images</code></pre> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818001627538.png" alt="image-20200818001627538"></p> <pre><code class="language-bash">#3.删除本地镜像\ndocker rmi 镜像的标识，Image ID</code></pre> <pre><code class="language-bash">#4.镜像的导入导出（不规范）\n#将本地镜像导出\ndocker save -o 导出的路径 镜像id\n#加载本地镜像\ndocker load -i 镜像文件\n#修改镜像名称\ndocker tag 镜像id 新镜像名称:tag</code></pre> <h2 id="24容器的操作">2.4容器的操作</h2> <pre><code class="language-bash">运行容器需要定制具体镜像，如果镜像不存在，会直接下载\n#1简单操作\ndocker run 镜像的标识|镜像的名称[:tag]\n#常用的参数\ndocker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]\n#-d:代表后台运行容器\n#-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口\n#--name 容器名称:指定容器的名称</code></pre> <pre><code class="language-bash">#2查看全部正在运行的容器信息\ndocker ps [-qa]\n#-a 查看全部的容器，包括没有运行\n#-q 只查看容器的标识</code></pre> <pre><code class="language-sh">#3查看容器的日志\ndocker logs -f IMAGEID\n#-f:滚动查看后几行</code></pre> <pre><code class="language-sh">#4.进入到容器内部\ndocker exec -it 容器ID bash</code></pre> <pre><code class="language-sh">#5.删除容器\ndocker stop 容器ID  #停止指定容器\ndocker rm 镜像ID #删除指定容器\n\ndocker stop $(docker ps -qa) #停止全部容器\ndocker rm $(docker ps -qa)  #删除全部容器</code></pre> <hr> <pre><code class="language-sh">#6.启动容器\ndocker start 容器id</code></pre> <h1 id="三docker应用">三.Docker应用</h1> <h2 id="31准备ssm工程">3.1准备SSM工程</h2> <pre><code class="language-sh">#运行Tomcat容器，为部署ssm工程做准备\n\ndocker run -d -p 8080:8080 --name tomcat  daocloud.io/library/tomcat:8.5.15-jre8\n#或者已经下载了tomcat镜像\ndocker run -d -p 8080:8080 --name tomcat 镜像的标识</code></pre> <h2 id="32准备mysql容器">3.2准备Mysql容器</h2> <pre><code class="language-sh">docker pull mysql/mysql-server:8.0\n\n docker volume create helloworld\n\n docker run -d -e MYSQL_ROOT_PASSWORD=root -v helloworld:/var/lib/mysql -p 3306:3306 mysql:8.0\n\ndocker run -d -p 3306:3306 --name mysql -e MYSQL-ROOT-PASSWORD=root e1c</code></pre> <h2 id="33准备tomcat容器">3.3准备Tomcat容器</h2> <h1 id="容器的另类操作（操作容器）">容器的另类操作（操作容器）</h1> <h2 id="tomcat管理">Tomcat管理</h2> <pre><code class="language-bash">docker exec -it 容器id /bin/bash #会进入tomcat目录，查看webapps发现是空文件夹，webapps.dist有内容，删除webapps，重命名webapps.dist为webapps</code></pre> ';n.exports=t},eea2:function(n,e){var t='<h1 id="hibernate框架">Hibernate框架</h1> <ol> <li><p>应用在javaee三层结构中Dao层框架</p> </li> <li><p>在Dao层对数据库CRUD操作，hibernate底层代码就是JDBC，Hibernate对JDBC进行封装，不需要复杂的代码，不需要写Sql语句实现；</p> </li> <li><p>Hibernate开源轻量级框架</p> </li> <li><p>Hibernate版本</p> <p>Hibernate3.X</p> <p>Hibernate4.X</p> <p>Hibernate5.X</p> </li> </ol> <h1 id="什么是orm思想">什么是ORM思想</h1> <ol> <li><p>Hiber 使用 ORM思想对数据库进行CRUD操作</p> </li> <li><p>在Web阶段学习Javabean 跟正确的叫法 实体类</p> </li> <li><p>ORM：对象关系映射</p> <p> 文字描述：</p> <p>（１）让实体类和数据库表进行一一对应</p> <p>​ 让实体类首先和数据库表对应</p> <p>​ 让实体属性和表里面字段对应</p> <p>（２）不需要直接操作数据库表，而操作表对应的实体类</p> <p>​ </p> </li> </ol> <p><img src="C:%5CUsers%5C79443%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201012213948649.png" alt="image-20201012213948649"></p> <h1 id="搭建环境">搭建环境</h1> <ol> <li>导入Jar包</li> </ol> ';n.exports=t},ef4c:function(n,e){var t='<p>昨晚安装搜狗输入法，最后电脑里除了输入法以外还多了爱奇艺、搜狗浏览器、QQ音乐、浏览器默认首页也被篡改。。。国产软件全家桶防不胜防（无奈 ╮(╯▽╰)╭ ）因此分享下各类干净安全的软件。</p> <p>拒绝安装软件：360旗下所有产品、2345旗下所有产品、百度旗下所有产品、腾讯管家、金山旗下所有产品（WPS，毒霸等等）、国产特供系列、还有各种下载站。</p> <p>我自己安装软件的原则就是能避开国产就避开国产软件，国产里面也要挑几个可靠的。</p> <p>能用付费就不用免费，Microsoft的东西就是最好的例子，人家服务好啊，付费和盗版就是不一样。</p> <p>免费里面选择开源的软件。</p> <p>下载东西一般都去官方网站直接下载，不考虑特供版的情况下都比较安全。Adobe Flash这种东西就呵呵。。精简破解的软件就去可靠的网站找比如<a href="http://www.52pojie.cn">www.52pojie.cn</a> 。</p> <p>推荐一些自己用的软件，部分附带链接：</p> <p>1.杀毒软件：火绒 <a href="http://www.huorong.cn">www.huorong.cn</a> （国产里面比较有良心的。。用的是Win10的话按时更新补丁自带的Defender够用。。杀毒软件一个就够了，拜托小姐姐们不要装那么多，除了电脑速度越来越慢以外并没有什么实际的用途。）</p> <p>你也可以去买卡巴斯基、诺顿、麦咖啡之类的国外杀毒软件。但这些软件对开发人员不友好。</p> <p>2.通讯软件：TIM、精简QQ、WeChat</p> <p>3.压缩软件：7zip <a href="https://www.7-zip.org%EF%BC%88%E5%BC%80%E6%BA%90%E3%80%81%E5%85%8D%E8%B4%B9%EF%BC%89">https://www.7-zip.org（开源、免费）</a></p> <p>4.浏览器：</p> <p>Chrome <a href="https://www.google.cn/intl/zh-CN/chrome/">https://www.google.cn/intl/zh-CN/chrome/</a></p> <p>Firefox <a href="https://www.mozilla.org/">https://www.mozilla.org/</a></p> <p>5.输入法：微软自带</p> <p>6.办公软件：Microsoft Office 365（家庭版500RMB/年。拒绝WPS）</p> <p>7.记事本：</p> <p>Notepad++：<a href="https://notepad-plus-plus.org/">https://notepad-plus-plus.org/</a></p> <p>Typora：<a href="https://typora.io/">https://typora.io/</a></p> <p>8.视频类：爱奇艺 、优酷 （Win10商店版 无广告）</p> <p>9.音乐：YouTube 网页 ：<a href="https://www.youtube.com">https://www.youtube.com</a></p> <p>10.邮件：Windows自带</p> <p>11.查找工具：Everything <a href="https://www.52pojie.cn/thread-998833-1-1.html">https://www.52pojie.cn/thread-998833-1-1.html</a></p> <p>12.视频播放：Potplayer （可以自己添加字幕等等）<a href="http://www.potplayer.org/">http://www.potplayer.org/</a></p> <p>13.重装系统：微Pe启动器：<a href="http://www.wepe.com.cn/">http://www.wepe.com.cn/</a></p> <p>14.Windows系统下载：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p> <p>15.Linus系统下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a> （清华大学开源网站）</p> <p>16.桌面美化：WallPaper Engine（Steam版本）</p> <p>17.广告拦截工具：Adguard：<a href="https://adguard.com/en/welcome.html">https://adguard.com/en/welcome.html</a> （圣诞节+黑色星期五 优惠力度超级大，85元一台电脑永久期限）</p> <p>BT资源（视频资源下载站）：</p> <p>有了这些网站都不要视频会员了，没有枪版资源。都是高清的</p> <p>1.六维空间：<a href="http://bt.neu6.edu.cn/forum.php">http://bt.neu6.edu.cn/forum.php</a> （东北大学 需要教育网）</p> <p>2.蒲公英：<a href="https://npupt.com/">https://npupt.com/</a> （西北工业大学 ipv6/教育网）</p> <p>3.北洋园：<a href="https://tjupt.org/">https://tjupt.org/</a> （天津大学 支持公网/ipv4/ipv6）</p> ';n.exports=t},f5f9:function(n,e,t){n.exports=t.p+"img/telegram.edc9a0ed.png"},f8aa:function(n,e){var t='<h1 id="1安装docker">1.安装Docker</h1> <h1 id="2安装docker-compose">2.安装Docker Compose</h1> <pre><code class="language-sh">第一条：\n sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose \n\n第二条：\n sudo chmod +x /usr/local/bin/docker-compose \n\n安装完成后，可以使用以下命令验证安装结果：\n docker-compose --version</code></pre> <h1 id="3pull-nacos">3.Pull Nacos</h1> <h2 id="操作步骤">操作步骤</h2> <ul> <li><p>Clone 项目</p> <pre><code class="language-sh">git clone https://github.com/nacos-group/nacos-docker.git\ncd nacos-docker</code></pre> </li> <li><p>单机模式 Derby</p> <pre><code class="language-sh">docker-compose -f example/standalone-derby.yaml up</code></pre> </li> <li><p>单机模式 Mysql</p> <pre><code class="language-sh">docker-compose -f example/standalone-mysql.yaml up\n\n//有版本的区别\ndocker-compose -f example/standalone-mysql-8.yaml up -d\n\ndocker-compose -f example/standalone-mysql-5.7.yaml up</code></pre> </li> </ul> <ul> <li><p>集群模式</p> <pre><code class="language-sh">docker-compose -f example/cluster-hostname.yaml up </code></pre> </li> <li><p>服务注册</p> <pre><code class="language-sh">curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#39;</code></pre> </li> <li><p>服务发现</p> <pre><code class="language-sh">curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instances?serviceName=nacos.naming.serviceName&#39;</code></pre> </li> <li><p>发布配置</p> <pre><code class="language-sh">curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld&quot;</code></pre> </li> <li><p>获取配置</p> <pre><code class="language-sh">  curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;</code></pre> </li> </ul> <h1 id="4查看日志">4.查看日志</h1> <pre><code class="language-sh">docker-compose -f example/standalone-mysql-5.7.yaml logs -f\n\ndocker-compose -f example/standalone-mysql-8.yaml logs -f</code></pre> <h1 id="5控制地址">5.控制地址</h1> <p><a href="http://192.168.187.128:8848/nacos">http://192.168.187.128:8848/nacos</a></p> <p>nacos nacos</p> <h1 id="6端点检查">6.端点检查</h1> <p><a href="http://localhost:8081/actuator/nacos-discovery">http://localhost:8081/actuator/nacos-discovery</a></p> ';n.exports=t},fdbc:function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}}}]);
//# sourceMappingURL=about.e1265faf.js.map